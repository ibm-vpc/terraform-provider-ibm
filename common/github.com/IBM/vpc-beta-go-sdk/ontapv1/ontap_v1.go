/**
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.80.0-29334a73-20230925-151553
 */

// Package ontapv1 : Operations and models for the OntapV1 service
package ontapv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/vpc-beta-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// OntapV1 : No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
//
// API Version: development-today
type OntapV1 struct {
	Service *core.BaseService

	// The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between `2023-12-18`
	// and `2023-12-18`.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.iaas.cloud.ibm.com/ontap/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "ontap"

// OntapV1Options : Service options
type OntapV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// The API version, in format `YYYY-MM-DD`. For the API behavior documented here, specify any date between `2023-12-18`
	// and `2023-12-18`.
	Version *string
}

// NewOntapV1UsingExternalConfig : constructs an instance of OntapV1 with passed in options and external configuration.
func NewOntapV1UsingExternalConfig(options *OntapV1Options) (ontap *OntapV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	ontap, err = NewOntapV1(options)
	if err != nil {
		return
	}

	err = ontap.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = ontap.Service.SetServiceURL(options.URL)
	}
	return
}

// NewOntapV1 : constructs an instance of OntapV1 with passed in options.
func NewOntapV1(options *OntapV1Options) (service *OntapV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	if options.Version == nil {
		options.Version = core.StringPtr("2023-12-12")
	}

	service = &OntapV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "ontap" suitable for processing requests.
func (ontap *OntapV1) Clone() *OntapV1 {
	if core.IsNil(ontap) {
		return nil
	}
	clone := *ontap
	clone.Service = ontap.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (ontap *OntapV1) SetServiceURL(url string) error {
	return ontap.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (ontap *OntapV1) GetServiceURL() string {
	return ontap.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (ontap *OntapV1) SetDefaultHeaders(headers http.Header) {
	ontap.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (ontap *OntapV1) SetEnableGzipCompression(enableGzip bool) {
	ontap.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (ontap *OntapV1) GetEnableGzipCompression() bool {
	return ontap.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (ontap *OntapV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	ontap.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (ontap *OntapV1) DisableRetries() {
	ontap.Service.DisableRetries()
}

// ListStorageOntapInstances : List all storage ontap instances
// This request lists all storage ontap instances in the region. A storage ontap instance is a highly-available NetApp
// CVO (Cloud Volumes ONTAP) deployment that provides storage which can be made available over the NFS and SMB/CIFS
// protocols.
//
// The storage ontap instances will be sorted by their `created_at` property values, with newest storage ontap instances
// first. Storage ontap instances with identical
// `created_at` property values will in turn be sorted by ascending `name` property values.
func (ontap *OntapV1) ListStorageOntapInstances(listStorageOntapInstancesOptions *ListStorageOntapInstancesOptions) (result *StorageOntapInstanceCollection, response *core.DetailedResponse, err error) {
	return ontap.ListStorageOntapInstancesWithContext(context.Background(), listStorageOntapInstancesOptions)
}

// ListStorageOntapInstancesWithContext is an alternate form of the ListStorageOntapInstances method which supports a Context parameter
func (ontap *OntapV1) ListStorageOntapInstancesWithContext(ctx context.Context, listStorageOntapInstancesOptions *ListStorageOntapInstancesOptions) (result *StorageOntapInstanceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listStorageOntapInstancesOptions, "listStorageOntapInstancesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listStorageOntapInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "ListStorageOntapInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))
	if listStorageOntapInstancesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listStorageOntapInstancesOptions.Start))
	}
	if listStorageOntapInstancesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listStorageOntapInstancesOptions.Limit))
	}
	if listStorageOntapInstancesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listStorageOntapInstancesOptions.ResourceGroupID))
	}
	if listStorageOntapInstancesOptions.LifecycleState != nil {
		builder.AddQuery("lifecycle_state", fmt.Sprint(*listStorageOntapInstancesOptions.LifecycleState))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateStorageOntapInstance : Create a storage ontap instance
// This request creates a new storage ontap instance from a storage ontap instance prototype object. The prototype
// object is structured in the same way as a retrieved storage ontap instance, and contains the information necessary to
// create the new storage ontap instance.
func (ontap *OntapV1) CreateStorageOntapInstance(createStorageOntapInstanceOptions *CreateStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	return ontap.CreateStorageOntapInstanceWithContext(context.Background(), createStorageOntapInstanceOptions)
}

// CreateStorageOntapInstanceWithContext is an alternate form of the CreateStorageOntapInstance method which supports a Context parameter
func (ontap *OntapV1) CreateStorageOntapInstanceWithContext(ctx context.Context, createStorageOntapInstanceOptions *CreateStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createStorageOntapInstanceOptions, "createStorageOntapInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createStorageOntapInstanceOptions, "createStorageOntapInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createStorageOntapInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "CreateStorageOntapInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	body := make(map[string]interface{})
	if createStorageOntapInstanceOptions.AddressPrefix != nil {
		body["address_prefix"] = createStorageOntapInstanceOptions.AddressPrefix
	}
	if createStorageOntapInstanceOptions.Capacity != nil {
		body["capacity"] = createStorageOntapInstanceOptions.Capacity
	}
	if createStorageOntapInstanceOptions.StorageVirtualMachines != nil {
		body["storage_virtual_machines"] = createStorageOntapInstanceOptions.StorageVirtualMachines
	}
	if createStorageOntapInstanceOptions.AdminCredentials != nil {
		body["admin_credentials"] = createStorageOntapInstanceOptions.AdminCredentials
	}
	if createStorageOntapInstanceOptions.EncryptionKey != nil {
		body["encryption_key"] = createStorageOntapInstanceOptions.EncryptionKey
	}
	if createStorageOntapInstanceOptions.Name != nil {
		body["name"] = createStorageOntapInstanceOptions.Name
	}
	if createStorageOntapInstanceOptions.PrimarySubnet != nil {
		body["primary_subnet"] = createStorageOntapInstanceOptions.PrimarySubnet
	}
	if createStorageOntapInstanceOptions.ResourceGroup != nil {
		body["resource_group"] = createStorageOntapInstanceOptions.ResourceGroup
	}
	if createStorageOntapInstanceOptions.RoutingTables != nil {
		body["routing_tables"] = createStorageOntapInstanceOptions.RoutingTables
	}
	if createStorageOntapInstanceOptions.SecondarySubnet != nil {
		body["secondary_subnet"] = createStorageOntapInstanceOptions.SecondarySubnet
	}
	if createStorageOntapInstanceOptions.SecurityGroups != nil {
		body["security_groups"] = createStorageOntapInstanceOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteStorageOntapInstance : Delete a storage ontap instance
// This request deletes a storage ontap instance. This operation cannot be reversed.
func (ontap *OntapV1) DeleteStorageOntapInstance(deleteStorageOntapInstanceOptions *DeleteStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	return ontap.DeleteStorageOntapInstanceWithContext(context.Background(), deleteStorageOntapInstanceOptions)
}

// DeleteStorageOntapInstanceWithContext is an alternate form of the DeleteStorageOntapInstance method which supports a Context parameter
func (ontap *OntapV1) DeleteStorageOntapInstanceWithContext(ctx context.Context, deleteStorageOntapInstanceOptions *DeleteStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteStorageOntapInstanceOptions, "deleteStorageOntapInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteStorageOntapInstanceOptions, "deleteStorageOntapInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteStorageOntapInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteStorageOntapInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "DeleteStorageOntapInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if deleteStorageOntapInstanceOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteStorageOntapInstanceOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetStorageOntapInstance : Retrieve a storage ontap instance
// This request retrieves a single storage ontap instance specified by the identifier in the URL.
func (ontap *OntapV1) GetStorageOntapInstance(getStorageOntapInstanceOptions *GetStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	return ontap.GetStorageOntapInstanceWithContext(context.Background(), getStorageOntapInstanceOptions)
}

// GetStorageOntapInstanceWithContext is an alternate form of the GetStorageOntapInstance method which supports a Context parameter
func (ontap *OntapV1) GetStorageOntapInstanceWithContext(ctx context.Context, getStorageOntapInstanceOptions *GetStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStorageOntapInstanceOptions, "getStorageOntapInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStorageOntapInstanceOptions, "getStorageOntapInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *getStorageOntapInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageOntapInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "GetStorageOntapInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateStorageOntapInstance : Update a storage ontap instance
// This request updates a storage ontap instance with the information in a provided storage ontap patch. The storage
// ontap instance patch object is structured in the same way as a retrieved storage ontap instance and contains only the
// information to be updated.
func (ontap *OntapV1) UpdateStorageOntapInstance(updateStorageOntapInstanceOptions *UpdateStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	return ontap.UpdateStorageOntapInstanceWithContext(context.Background(), updateStorageOntapInstanceOptions)
}

// UpdateStorageOntapInstanceWithContext is an alternate form of the UpdateStorageOntapInstance method which supports a Context parameter
func (ontap *OntapV1) UpdateStorageOntapInstanceWithContext(ctx context.Context, updateStorageOntapInstanceOptions *UpdateStorageOntapInstanceOptions) (result *StorageOntapInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateStorageOntapInstanceOptions, "updateStorageOntapInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateStorageOntapInstanceOptions, "updateStorageOntapInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateStorageOntapInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateStorageOntapInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "UpdateStorageOntapInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateStorageOntapInstanceOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateStorageOntapInstanceOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	_, err = builder.SetBodyContentJSON(updateStorageOntapInstanceOptions.StorageOntapInstancePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// RefreshCredentialsStorageOntapInstance : Refresh credentials for a storage ontap instance
// This request triggers a refresh of all credentials property values for the storage ontap instance specified by the
// identifier in the URL.
func (ontap *OntapV1) RefreshCredentialsStorageOntapInstance(refreshCredentialsStorageOntapInstanceOptions *RefreshCredentialsStorageOntapInstanceOptions) (response *core.DetailedResponse, err error) {
	return ontap.RefreshCredentialsStorageOntapInstanceWithContext(context.Background(), refreshCredentialsStorageOntapInstanceOptions)
}

// RefreshCredentialsStorageOntapInstanceWithContext is an alternate form of the RefreshCredentialsStorageOntapInstance method which supports a Context parameter
func (ontap *OntapV1) RefreshCredentialsStorageOntapInstanceWithContext(ctx context.Context, refreshCredentialsStorageOntapInstanceOptions *RefreshCredentialsStorageOntapInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(refreshCredentialsStorageOntapInstanceOptions, "refreshCredentialsStorageOntapInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(refreshCredentialsStorageOntapInstanceOptions, "refreshCredentialsStorageOntapInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"id": *refreshCredentialsStorageOntapInstanceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{id}/refresh_credentials`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range refreshCredentialsStorageOntapInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "RefreshCredentialsStorageOntapInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = ontap.Service.Request(request, nil)

	return
}

// ListStorageOntapInstanceStorageVirtualMachines : List all storage virtual machines for a storage ontap instance
// This request lists all storage virtual machines for a given storage ontap instance. A storage virtual machine
// partitions a storage ontap instance for different sets of users, and allows common policies to be defined for its
// storage volumes.
//
// The storage virtual machines will be sorted by their `created_at` property values, with newest storage virtual
// machines first. Storage virtual machines with identical
// `created_at` property values will in turn be sorted by ascending `name` property values.
func (ontap *OntapV1) ListStorageOntapInstanceStorageVirtualMachines(listStorageOntapInstanceStorageVirtualMachinesOptions *ListStorageOntapInstanceStorageVirtualMachinesOptions) (result *StorageOntapInstanceStorageVirtualMachineCollection, response *core.DetailedResponse, err error) {
	return ontap.ListStorageOntapInstanceStorageVirtualMachinesWithContext(context.Background(), listStorageOntapInstanceStorageVirtualMachinesOptions)
}

// ListStorageOntapInstanceStorageVirtualMachinesWithContext is an alternate form of the ListStorageOntapInstanceStorageVirtualMachines method which supports a Context parameter
func (ontap *OntapV1) ListStorageOntapInstanceStorageVirtualMachinesWithContext(ctx context.Context, listStorageOntapInstanceStorageVirtualMachinesOptions *ListStorageOntapInstanceStorageVirtualMachinesOptions) (result *StorageOntapInstanceStorageVirtualMachineCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listStorageOntapInstanceStorageVirtualMachinesOptions, "listStorageOntapInstanceStorageVirtualMachinesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listStorageOntapInstanceStorageVirtualMachinesOptions, "listStorageOntapInstanceStorageVirtualMachinesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id": *listStorageOntapInstanceStorageVirtualMachinesOptions.StorageOntapInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listStorageOntapInstanceStorageVirtualMachinesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "ListStorageOntapInstanceStorageVirtualMachines")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))
	if listStorageOntapInstanceStorageVirtualMachinesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachinesOptions.Start))
	}
	if listStorageOntapInstanceStorageVirtualMachinesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachinesOptions.Limit))
	}
	if listStorageOntapInstanceStorageVirtualMachinesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachinesOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetStorageOntapInstanceStorageVirtualMachine : Retrieve a storage virtual machine
// This request retrieves a single storage virtual machine specified by the identifier in the URL.
func (ontap *OntapV1) GetStorageOntapInstanceStorageVirtualMachine(getStorageOntapInstanceStorageVirtualMachineOptions *GetStorageOntapInstanceStorageVirtualMachineOptions) (result *StorageOntapInstanceStorageVirtualMachine, response *core.DetailedResponse, err error) {
	return ontap.GetStorageOntapInstanceStorageVirtualMachineWithContext(context.Background(), getStorageOntapInstanceStorageVirtualMachineOptions)
}

// GetStorageOntapInstanceStorageVirtualMachineWithContext is an alternate form of the GetStorageOntapInstanceStorageVirtualMachine method which supports a Context parameter
func (ontap *OntapV1) GetStorageOntapInstanceStorageVirtualMachineWithContext(ctx context.Context, getStorageOntapInstanceStorageVirtualMachineOptions *GetStorageOntapInstanceStorageVirtualMachineOptions) (result *StorageOntapInstanceStorageVirtualMachine, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStorageOntapInstanceStorageVirtualMachineOptions, "getStorageOntapInstanceStorageVirtualMachineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStorageOntapInstanceStorageVirtualMachineOptions, "getStorageOntapInstanceStorageVirtualMachineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id": *getStorageOntapInstanceStorageVirtualMachineOptions.StorageOntapInstanceID,
		"id":                        *getStorageOntapInstanceStorageVirtualMachineOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageOntapInstanceStorageVirtualMachineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "GetStorageOntapInstanceStorageVirtualMachine")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachine)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateStorageOntapInstanceStorageVirtualMachine : Update a storage virtual machine
// This request updates a storage virtual machine with the information in a provided storage virtual machine patch. The
// storage virtual machine patch object is structured in the same way as a retrieved storage virtual machine and
// contains only the information to be updated.
func (ontap *OntapV1) UpdateStorageOntapInstanceStorageVirtualMachine(updateStorageOntapInstanceStorageVirtualMachineOptions *UpdateStorageOntapInstanceStorageVirtualMachineOptions) (result *StorageOntapInstanceStorageVirtualMachine, response *core.DetailedResponse, err error) {
	return ontap.UpdateStorageOntapInstanceStorageVirtualMachineWithContext(context.Background(), updateStorageOntapInstanceStorageVirtualMachineOptions)
}

// UpdateStorageOntapInstanceStorageVirtualMachineWithContext is an alternate form of the UpdateStorageOntapInstanceStorageVirtualMachine method which supports a Context parameter
func (ontap *OntapV1) UpdateStorageOntapInstanceStorageVirtualMachineWithContext(ctx context.Context, updateStorageOntapInstanceStorageVirtualMachineOptions *UpdateStorageOntapInstanceStorageVirtualMachineOptions) (result *StorageOntapInstanceStorageVirtualMachine, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateStorageOntapInstanceStorageVirtualMachineOptions, "updateStorageOntapInstanceStorageVirtualMachineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateStorageOntapInstanceStorageVirtualMachineOptions, "updateStorageOntapInstanceStorageVirtualMachineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id": *updateStorageOntapInstanceStorageVirtualMachineOptions.StorageOntapInstanceID,
		"id":                        *updateStorageOntapInstanceStorageVirtualMachineOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateStorageOntapInstanceStorageVirtualMachineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "UpdateStorageOntapInstanceStorageVirtualMachine")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateStorageOntapInstanceStorageVirtualMachineOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateStorageOntapInstanceStorageVirtualMachineOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	_, err = builder.SetBodyContentJSON(updateStorageOntapInstanceStorageVirtualMachineOptions.StorageOntapInstanceStorageVirtualMachinePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachine)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListStorageOntapInstanceStorageVirtualMachineVolumes : List all storage volumes for a storage virtual machine
// This request lists all storage volumes for a storage virtual machine. Each storage volume uses storage capacity from
// its parent storage virtual machine and provides a file share which can be made available over the NFS and SMB/CIFS
// protocols.
//
// The storage volumes will be sorted by their `created_at` property values, with newest storage volumes first. Storage
// volumes with identical `created_at` property values will in turn be sorted by ascending `name` property values.
func (ontap *OntapV1) ListStorageOntapInstanceStorageVirtualMachineVolumes(listStorageOntapInstanceStorageVirtualMachineVolumesOptions *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) (result *StorageOntapInstanceStorageVirtualMachineVolumeCollection, response *core.DetailedResponse, err error) {
	return ontap.ListStorageOntapInstanceStorageVirtualMachineVolumesWithContext(context.Background(), listStorageOntapInstanceStorageVirtualMachineVolumesOptions)
}

// ListStorageOntapInstanceStorageVirtualMachineVolumesWithContext is an alternate form of the ListStorageOntapInstanceStorageVirtualMachineVolumes method which supports a Context parameter
func (ontap *OntapV1) ListStorageOntapInstanceStorageVirtualMachineVolumesWithContext(ctx context.Context, listStorageOntapInstanceStorageVirtualMachineVolumesOptions *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) (result *StorageOntapInstanceStorageVirtualMachineVolumeCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listStorageOntapInstanceStorageVirtualMachineVolumesOptions, "listStorageOntapInstanceStorageVirtualMachineVolumesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listStorageOntapInstanceStorageVirtualMachineVolumesOptions, "listStorageOntapInstanceStorageVirtualMachineVolumesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id":  *listStorageOntapInstanceStorageVirtualMachineVolumesOptions.StorageOntapInstanceID,
		"storage_virtual_machine_id": *listStorageOntapInstanceStorageVirtualMachineVolumesOptions.StorageVirtualMachineID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{storage_virtual_machine_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "ListStorageOntapInstanceStorageVirtualMachineVolumes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))
	if listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Start))
	}
	if listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Limit))
	}
	if listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listStorageOntapInstanceStorageVirtualMachineVolumesOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateStorageOntapInstanceStorageVirtualMachineVolume : Create a storage volume
// This request creates a new storage volume from storage volume prototype object. The prototype object is structured in
// the same way as a retrieved storage volume, and contains the information necessary to create the new storage volume.
func (ontap *OntapV1) CreateStorageOntapInstanceStorageVirtualMachineVolume(createStorageOntapInstanceStorageVirtualMachineVolumeOptions *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	return ontap.CreateStorageOntapInstanceStorageVirtualMachineVolumeWithContext(context.Background(), createStorageOntapInstanceStorageVirtualMachineVolumeOptions)
}

// CreateStorageOntapInstanceStorageVirtualMachineVolumeWithContext is an alternate form of the CreateStorageOntapInstanceStorageVirtualMachineVolume method which supports a Context parameter
func (ontap *OntapV1) CreateStorageOntapInstanceStorageVirtualMachineVolumeWithContext(ctx context.Context, createStorageOntapInstanceStorageVirtualMachineVolumeOptions *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createStorageOntapInstanceStorageVirtualMachineVolumeOptions, "createStorageOntapInstanceStorageVirtualMachineVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createStorageOntapInstanceStorageVirtualMachineVolumeOptions, "createStorageOntapInstanceStorageVirtualMachineVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id":  *createStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceID,
		"storage_virtual_machine_id": *createStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageVirtualMachineID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{storage_virtual_machine_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createStorageOntapInstanceStorageVirtualMachineVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "CreateStorageOntapInstanceStorageVirtualMachineVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	_, err = builder.SetBodyContentJSON(createStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceStorageVirtualMachineVolumePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteStorageOntapInstanceStorageVirtualMachineVolume : Delete a storage volume
// This request deletes a storage volume. This operation cannot be reversed.
func (ontap *OntapV1) DeleteStorageOntapInstanceStorageVirtualMachineVolume(deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	return ontap.DeleteStorageOntapInstanceStorageVirtualMachineVolumeWithContext(context.Background(), deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions)
}

// DeleteStorageOntapInstanceStorageVirtualMachineVolumeWithContext is an alternate form of the DeleteStorageOntapInstanceStorageVirtualMachineVolume method which supports a Context parameter
func (ontap *OntapV1) DeleteStorageOntapInstanceStorageVirtualMachineVolumeWithContext(ctx context.Context, deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions, "deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions, "deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id":  *deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceID,
		"storage_virtual_machine_id": *deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageVirtualMachineID,
		"id":                         *deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{storage_virtual_machine_id}/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "DeleteStorageOntapInstanceStorageVirtualMachineVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*deleteStorageOntapInstanceStorageVirtualMachineVolumeOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetStorageOntapInstanceStorageVirtualMachineVolume : Retrieve a storage volume
// This request retrieves a single storage volume specified by the identifier in the URL.
func (ontap *OntapV1) GetStorageOntapInstanceStorageVirtualMachineVolume(getStorageOntapInstanceStorageVirtualMachineVolumeOptions *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	return ontap.GetStorageOntapInstanceStorageVirtualMachineVolumeWithContext(context.Background(), getStorageOntapInstanceStorageVirtualMachineVolumeOptions)
}

// GetStorageOntapInstanceStorageVirtualMachineVolumeWithContext is an alternate form of the GetStorageOntapInstanceStorageVirtualMachineVolume method which supports a Context parameter
func (ontap *OntapV1) GetStorageOntapInstanceStorageVirtualMachineVolumeWithContext(ctx context.Context, getStorageOntapInstanceStorageVirtualMachineVolumeOptions *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStorageOntapInstanceStorageVirtualMachineVolumeOptions, "getStorageOntapInstanceStorageVirtualMachineVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStorageOntapInstanceStorageVirtualMachineVolumeOptions, "getStorageOntapInstanceStorageVirtualMachineVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id":  *getStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceID,
		"storage_virtual_machine_id": *getStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageVirtualMachineID,
		"id":                         *getStorageOntapInstanceStorageVirtualMachineVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{storage_virtual_machine_id}/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageOntapInstanceStorageVirtualMachineVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "GetStorageOntapInstanceStorageVirtualMachineVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateStorageOntapInstanceStorageVirtualMachineVolume : Update a storage volume
// This request updates a storage volume with the information provided in the storage volume patch. The storage volume
// patch object is structured in the same way as a retrieved storage volume and contains only the information to be
// updated.
func (ontap *OntapV1) UpdateStorageOntapInstanceStorageVirtualMachineVolume(updateStorageOntapInstanceStorageVirtualMachineVolumeOptions *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	return ontap.UpdateStorageOntapInstanceStorageVirtualMachineVolumeWithContext(context.Background(), updateStorageOntapInstanceStorageVirtualMachineVolumeOptions)
}

// UpdateStorageOntapInstanceStorageVirtualMachineVolumeWithContext is an alternate form of the UpdateStorageOntapInstanceStorageVirtualMachineVolume method which supports a Context parameter
func (ontap *OntapV1) UpdateStorageOntapInstanceStorageVirtualMachineVolumeWithContext(ctx context.Context, updateStorageOntapInstanceStorageVirtualMachineVolumeOptions *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) (result *StorageOntapInstanceStorageVirtualMachineVolume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateStorageOntapInstanceStorageVirtualMachineVolumeOptions, "updateStorageOntapInstanceStorageVirtualMachineVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateStorageOntapInstanceStorageVirtualMachineVolumeOptions, "updateStorageOntapInstanceStorageVirtualMachineVolumeOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"storage_ontap_instance_id":  *updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceID,
		"storage_virtual_machine_id": *updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageVirtualMachineID,
		"id":                         *updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = ontap.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(ontap.Service.Options.URL, `/storage_ontap_instances/{storage_ontap_instance_id}/storage_virtual_machines/{storage_virtual_machine_id}/volumes/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("ontap", "V1", "UpdateStorageOntapInstanceStorageVirtualMachineVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")
	if updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*ontap.Version))

	_, err = builder.SetBodyContentJSON(updateStorageOntapInstanceStorageVirtualMachineVolumeOptions.StorageOntapInstanceStorageVirtualMachineVolumePatch)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = ontap.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageOntapInstanceStorageVirtualMachineVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AddressPrefixIdentity : Identifies an address prefix by a unique property.
// Models which "extend" this model:
// - AddressPrefixIdentityByID
// - AddressPrefixIdentityByHref
type AddressPrefixIdentity struct {
	// The unique identifier for this address prefix.
	ID *string `json:"id,omitempty"`

	// The URL for this address prefix.
	Href *string `json:"href,omitempty"`
}

func (*AddressPrefixIdentity) isaAddressPrefixIdentity() bool {
	return true
}

type AddressPrefixIdentityIntf interface {
	isaAddressPrefixIdentity() bool
}

// UnmarshalAddressPrefixIdentity unmarshals an instance of AddressPrefixIdentity from the specified map of raw messages.
func UnmarshalAddressPrefixIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixReference : AddressPrefixReference struct
type AddressPrefixReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *AddressPrefixReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this address prefix.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this address prefix.
	ID *string `json:"id" validate:"required"`

	// The name for this address prefix. The name is unique across all address prefixes for the VPC.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalAddressPrefixReference unmarshals an instance of AddressPrefixReference from the specified map of raw messages.
func UnmarshalAddressPrefixReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalAddressPrefixReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type AddressPrefixReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalAddressPrefixReferenceDeleted unmarshals an instance of AddressPrefixReferenceDeleted from the specified map of raw messages.
func UnmarshalAddressPrefixReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateStorageOntapInstanceOptions : The CreateStorageOntapInstance options.
type CreateStorageOntapInstanceOptions struct {
	// The VPC's address prefix which will be used to allocate `endpoints` for this
	// storage ontap instance and its storage virtual machines.
	// The address range must:
	// - not be in use by another storage ontap instance
	// - not overlap with any subnets
	// See [the documentation](https://cloud.ibm.com/docs/vpc?topic=__TBD__) on how to
	// manage IP addresses for storage ontap instances.
	AddressPrefix AddressPrefixIdentityIntf `json:"address_prefix" validate:"required"`

	// The capacity to use for the storage ontap instance (in terabytes). Volumes in this storage ontap instance will be
	// allocated from this capacity.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The storage virtual machines to create for this storage ontap instance.
	StorageVirtualMachines []StorageOntapInstanceStorageVirtualMachinePrototype `json:"storage_virtual_machines" validate:"required"`

	// The credentials to use (from Secrets Manager) for the cluster administrator to access the
	// storage ontap instance. At least one of `password`, `ssh`, or `http` must be specified.
	AdminCredentials *StorageOntapInstanceAdminCredentialsPrototype `json:"admin_credentials,omitempty"`

	// The root key to use to wrap the data encryption key for the storage ontap instance.
	//
	// If unspecified, the `encryption` type the will be `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The name for this storage ontap instance. The name must not be used by another storage ontap instance in the region.
	// The name must be prefixed with `ibmss-`.
	//
	// If unspecified, the name will be a hyphenated list of randomly-selected words starting with `ibmss-`.
	Name *string `json:"name,omitempty"`

	// The primary subnet to provision this storage ontap instance in.
	// The specified subnet must be in a different zone from the `secondary_subnet`.
	//
	// If specified, `secondary_subnet` must also be specified.
	// If `primary_subnet` and `secondary_subnet` are specified, then `primary_subnet` and
	// `secondary_subnet` must not be specified.
	PrimarySubnet SubnetIdentityIntf `json:"primary_subnet,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC routing tables to use for this storage ontap instance. Routes will be added by the service in these routing
	// tables to allow virtual server instances to access the endpoints of this storage ontap instance.
	//
	// If unspecified, the VPC's default routing table is used.
	RoutingTables []RoutingTableIdentityIntf `json:"routing_tables,omitempty"`

	// The secondary subnet to provision this storage ontap instance in.
	// The specified subnet must be in a different zone from the `primary_subnet`.
	//
	// If specified, `primary_subnet` must also be specified.
	// If `primary_subnet` and `secondary_subnet` are specified, then `primary_subnet` and
	// `secondary_subnet` must not be specified.
	SecondarySubnet SubnetIdentityIntf `json:"secondary_subnet,omitempty"`

	// The security groups to use for this storage ontap instance.
	//
	// If unspecified, the VPC's default security group is used.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateStorageOntapInstanceOptions : Instantiate CreateStorageOntapInstanceOptions
func (*OntapV1) NewCreateStorageOntapInstanceOptions(addressPrefix AddressPrefixIdentityIntf, capacity int64, storageVirtualMachines []StorageOntapInstanceStorageVirtualMachinePrototype) *CreateStorageOntapInstanceOptions {
	return &CreateStorageOntapInstanceOptions{
		AddressPrefix:          addressPrefix,
		Capacity:               core.Int64Ptr(capacity),
		StorageVirtualMachines: storageVirtualMachines,
	}
}

// SetAddressPrefix : Allow user to set AddressPrefix
func (_options *CreateStorageOntapInstanceOptions) SetAddressPrefix(addressPrefix AddressPrefixIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.AddressPrefix = addressPrefix
	return _options
}

// SetCapacity : Allow user to set Capacity
func (_options *CreateStorageOntapInstanceOptions) SetCapacity(capacity int64) *CreateStorageOntapInstanceOptions {
	_options.Capacity = core.Int64Ptr(capacity)
	return _options
}

// SetStorageVirtualMachines : Allow user to set StorageVirtualMachines
func (_options *CreateStorageOntapInstanceOptions) SetStorageVirtualMachines(storageVirtualMachines []StorageOntapInstanceStorageVirtualMachinePrototype) *CreateStorageOntapInstanceOptions {
	_options.StorageVirtualMachines = storageVirtualMachines
	return _options
}

// SetAdminCredentials : Allow user to set AdminCredentials
func (_options *CreateStorageOntapInstanceOptions) SetAdminCredentials(adminCredentials *StorageOntapInstanceAdminCredentialsPrototype) *CreateStorageOntapInstanceOptions {
	_options.AdminCredentials = adminCredentials
	return _options
}

// SetEncryptionKey : Allow user to set EncryptionKey
func (_options *CreateStorageOntapInstanceOptions) SetEncryptionKey(encryptionKey EncryptionKeyIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.EncryptionKey = encryptionKey
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateStorageOntapInstanceOptions) SetName(name string) *CreateStorageOntapInstanceOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPrimarySubnet : Allow user to set PrimarySubnet
func (_options *CreateStorageOntapInstanceOptions) SetPrimarySubnet(primarySubnet SubnetIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.PrimarySubnet = primarySubnet
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateStorageOntapInstanceOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetRoutingTables : Allow user to set RoutingTables
func (_options *CreateStorageOntapInstanceOptions) SetRoutingTables(routingTables []RoutingTableIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.RoutingTables = routingTables
	return _options
}

// SetSecondarySubnet : Allow user to set SecondarySubnet
func (_options *CreateStorageOntapInstanceOptions) SetSecondarySubnet(secondarySubnet SubnetIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.SecondarySubnet = secondarySubnet
	return _options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (_options *CreateStorageOntapInstanceOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateStorageOntapInstanceOptions {
	_options.SecurityGroups = securityGroups
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateStorageOntapInstanceOptions) SetHeaders(param map[string]string) *CreateStorageOntapInstanceOptions {
	options.Headers = param
	return options
}

// CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions : The CreateStorageOntapInstanceStorageVirtualMachineVolume options.
type CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	StorageVirtualMachineID *string `json:"storage_virtual_machine_id" validate:"required,ne="`

	// The storage volume prototype object.
	StorageOntapInstanceStorageVirtualMachineVolumePrototype StorageOntapInstanceStorageVirtualMachineVolumePrototypeIntf `json:"StorageOntapInstanceStorageVirtualMachineVolumePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateStorageOntapInstanceStorageVirtualMachineVolumeOptions : Instantiate CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions
func (*OntapV1) NewCreateStorageOntapInstanceStorageVirtualMachineVolumeOptions(storageOntapInstanceID string, storageVirtualMachineID string, storageOntapInstanceStorageVirtualMachineVolumePrototype StorageOntapInstanceStorageVirtualMachineVolumePrototypeIntf) *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	return &CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions{
		StorageOntapInstanceID:                                   core.StringPtr(storageOntapInstanceID),
		StorageVirtualMachineID:                                  core.StringPtr(storageVirtualMachineID),
		StorageOntapInstanceStorageVirtualMachineVolumePrototype: storageOntapInstanceStorageVirtualMachineVolumePrototype,
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStorageVirtualMachineID : Allow user to set StorageVirtualMachineID
func (_options *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageVirtualMachineID(storageVirtualMachineID string) *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageVirtualMachineID = core.StringPtr(storageVirtualMachineID)
	return _options
}

// SetStorageOntapInstanceStorageVirtualMachineVolumePrototype : Allow user to set StorageOntapInstanceStorageVirtualMachineVolumePrototype
func (_options *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceStorageVirtualMachineVolumePrototype(storageOntapInstanceStorageVirtualMachineVolumePrototype StorageOntapInstanceStorageVirtualMachineVolumePrototypeIntf) *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceStorageVirtualMachineVolumePrototype = storageOntapInstanceStorageVirtualMachineVolumePrototype
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetHeaders(param map[string]string) *CreateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	options.Headers = param
	return options
}

// CredentialIdentity : Identifies credential by a unique property.
// Models which "extend" this model:
// - CredentialIdentityByCRN
type CredentialIdentity struct {
	// The CRN for this credential.
	Crn *string `json:"crn,omitempty"`
}

func (*CredentialIdentity) isaCredentialIdentity() bool {
	return true
}

type CredentialIdentityIntf interface {
	isaCredentialIdentity() bool
}

// UnmarshalCredentialIdentity unmarshals an instance of CredentialIdentity from the specified map of raw messages.
func UnmarshalCredentialIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CredentialIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CredentialReference : CredentialReference struct
type CredentialReference struct {
	// The CRN for this credential.
	Crn *string `json:"crn" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the CredentialReference.ResourceType property.
// The resource type.
const (
	CredentialReference_ResourceType_Credential = "credential"
)

// UnmarshalCredentialReference unmarshals an instance of CredentialReference from the specified map of raw messages.
func UnmarshalCredentialReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CredentialReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteStorageOntapInstanceOptions : The DeleteStorageOntapInstance options.
type DeleteStorageOntapInstanceOptions struct {
	// The storage ontap instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteStorageOntapInstanceOptions : Instantiate DeleteStorageOntapInstanceOptions
func (*OntapV1) NewDeleteStorageOntapInstanceOptions(id string) *DeleteStorageOntapInstanceOptions {
	return &DeleteStorageOntapInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteStorageOntapInstanceOptions) SetID(id string) *DeleteStorageOntapInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteStorageOntapInstanceOptions) SetIfMatch(ifMatch string) *DeleteStorageOntapInstanceOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteStorageOntapInstanceOptions) SetHeaders(param map[string]string) *DeleteStorageOntapInstanceOptions {
	options.Headers = param
	return options
}

// DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions : The DeleteStorageOntapInstanceStorageVirtualMachineVolume options.
type DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	StorageVirtualMachineID *string `json:"storage_virtual_machine_id" validate:"required,ne="`

	// The storage volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions : Instantiate DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions
func (*OntapV1) NewDeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions(storageOntapInstanceID string, storageVirtualMachineID string, id string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	return &DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions{
		StorageOntapInstanceID:  core.StringPtr(storageOntapInstanceID),
		StorageVirtualMachineID: core.StringPtr(storageVirtualMachineID),
		ID:                      core.StringPtr(id),
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStorageVirtualMachineID : Allow user to set StorageVirtualMachineID
func (_options *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageVirtualMachineID(storageVirtualMachineID string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageVirtualMachineID = core.StringPtr(storageVirtualMachineID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetID(id string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetIfMatch(ifMatch string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetHeaders(param map[string]string) *DeleteStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	options.Headers = param
	return options
}

// EncryptionKeyIdentity : Identifies an encryption key by a unique property.
// Models which "extend" this model:
// - EncryptionKeyIdentityByCRN
type EncryptionKeyIdentity struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	Crn *string `json:"crn,omitempty"`
}

func (*EncryptionKeyIdentity) isaEncryptionKeyIdentity() bool {
	return true
}

type EncryptionKeyIdentityIntf interface {
	isaEncryptionKeyIdentity() bool
}

// UnmarshalEncryptionKeyIdentity unmarshals an instance of EncryptionKeyIdentity from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyReference : EncryptionKeyReference struct
type EncryptionKeyReference struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	Crn *string `json:"crn" validate:"required"`
}

// UnmarshalEncryptionKeyReference unmarshals an instance of EncryptionKeyReference from the specified map of raw messages.
func UnmarshalEncryptionKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetStorageOntapInstanceOptions : The GetStorageOntapInstance options.
type GetStorageOntapInstanceOptions struct {
	// The storage ontap instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageOntapInstanceOptions : Instantiate GetStorageOntapInstanceOptions
func (*OntapV1) NewGetStorageOntapInstanceOptions(id string) *GetStorageOntapInstanceOptions {
	return &GetStorageOntapInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetStorageOntapInstanceOptions) SetID(id string) *GetStorageOntapInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageOntapInstanceOptions) SetHeaders(param map[string]string) *GetStorageOntapInstanceOptions {
	options.Headers = param
	return options
}

// GetStorageOntapInstanceStorageVirtualMachineOptions : The GetStorageOntapInstanceStorageVirtualMachine options.
type GetStorageOntapInstanceStorageVirtualMachineOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageOntapInstanceStorageVirtualMachineOptions : Instantiate GetStorageOntapInstanceStorageVirtualMachineOptions
func (*OntapV1) NewGetStorageOntapInstanceStorageVirtualMachineOptions(storageOntapInstanceID string, id string) *GetStorageOntapInstanceStorageVirtualMachineOptions {
	return &GetStorageOntapInstanceStorageVirtualMachineOptions{
		StorageOntapInstanceID: core.StringPtr(storageOntapInstanceID),
		ID:                     core.StringPtr(id),
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *GetStorageOntapInstanceStorageVirtualMachineOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *GetStorageOntapInstanceStorageVirtualMachineOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetStorageOntapInstanceStorageVirtualMachineOptions) SetID(id string) *GetStorageOntapInstanceStorageVirtualMachineOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageOntapInstanceStorageVirtualMachineOptions) SetHeaders(param map[string]string) *GetStorageOntapInstanceStorageVirtualMachineOptions {
	options.Headers = param
	return options
}

// GetStorageOntapInstanceStorageVirtualMachineVolumeOptions : The GetStorageOntapInstanceStorageVirtualMachineVolume options.
type GetStorageOntapInstanceStorageVirtualMachineVolumeOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	StorageVirtualMachineID *string `json:"storage_virtual_machine_id" validate:"required,ne="`

	// The storage volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageOntapInstanceStorageVirtualMachineVolumeOptions : Instantiate GetStorageOntapInstanceStorageVirtualMachineVolumeOptions
func (*OntapV1) NewGetStorageOntapInstanceStorageVirtualMachineVolumeOptions(storageOntapInstanceID string, storageVirtualMachineID string, id string) *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	return &GetStorageOntapInstanceStorageVirtualMachineVolumeOptions{
		StorageOntapInstanceID:  core.StringPtr(storageOntapInstanceID),
		StorageVirtualMachineID: core.StringPtr(storageVirtualMachineID),
		ID:                      core.StringPtr(id),
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStorageVirtualMachineID : Allow user to set StorageVirtualMachineID
func (_options *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageVirtualMachineID(storageVirtualMachineID string) *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageVirtualMachineID = core.StringPtr(storageVirtualMachineID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetID(id string) *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetHeaders(param map[string]string) *GetStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	options.Headers = param
	return options
}

// ListStorageOntapInstanceStorageVirtualMachineVolumesOptions : The ListStorageOntapInstanceStorageVirtualMachineVolumes options.
type ListStorageOntapInstanceStorageVirtualMachineVolumesOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	StorageVirtualMachineID *string `json:"storage_virtual_machine_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListStorageOntapInstanceStorageVirtualMachineVolumesOptions : Instantiate ListStorageOntapInstanceStorageVirtualMachineVolumesOptions
func (*OntapV1) NewListStorageOntapInstanceStorageVirtualMachineVolumesOptions(storageOntapInstanceID string, storageVirtualMachineID string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	return &ListStorageOntapInstanceStorageVirtualMachineVolumesOptions{
		StorageOntapInstanceID:  core.StringPtr(storageOntapInstanceID),
		StorageVirtualMachineID: core.StringPtr(storageVirtualMachineID),
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStorageVirtualMachineID : Allow user to set StorageVirtualMachineID
func (_options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetStorageVirtualMachineID(storageVirtualMachineID string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	_options.StorageVirtualMachineID = core.StringPtr(storageVirtualMachineID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetStart(start string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetLimit(limit int64) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetName(name string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) SetHeaders(param map[string]string) *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions {
	options.Headers = param
	return options
}

// ListStorageOntapInstanceStorageVirtualMachinesOptions : The ListStorageOntapInstanceStorageVirtualMachines options.
type ListStorageOntapInstanceStorageVirtualMachinesOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `name` property matching the exact specified name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListStorageOntapInstanceStorageVirtualMachinesOptions : Instantiate ListStorageOntapInstanceStorageVirtualMachinesOptions
func (*OntapV1) NewListStorageOntapInstanceStorageVirtualMachinesOptions(storageOntapInstanceID string) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	return &ListStorageOntapInstanceStorageVirtualMachinesOptions{
		StorageOntapInstanceID: core.StringPtr(storageOntapInstanceID),
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *ListStorageOntapInstanceStorageVirtualMachinesOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListStorageOntapInstanceStorageVirtualMachinesOptions) SetStart(start string) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListStorageOntapInstanceStorageVirtualMachinesOptions) SetLimit(limit int64) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListStorageOntapInstanceStorageVirtualMachinesOptions) SetName(name string) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListStorageOntapInstanceStorageVirtualMachinesOptions) SetHeaders(param map[string]string) *ListStorageOntapInstanceStorageVirtualMachinesOptions {
	options.Headers = param
	return options
}

// ListStorageOntapInstancesOptions : The ListStorageOntapInstances options.
type ListStorageOntapInstancesOptions struct {
	// A server-provided token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with a `resource_group.id` property matching the specified identifier.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to storage ontap instances with a `lifecycle_state` property matching the specified value.
	LifecycleState *string `json:"lifecycle_state,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListStorageOntapInstancesOptions.LifecycleState property.
// Filters the collection to storage ontap instances with a `lifecycle_state` property matching the specified value.
const (
	ListStorageOntapInstancesOptions_LifecycleState_Deleting  = "deleting"
	ListStorageOntapInstancesOptions_LifecycleState_Failed    = "failed"
	ListStorageOntapInstancesOptions_LifecycleState_Pending   = "pending"
	ListStorageOntapInstancesOptions_LifecycleState_Stable    = "stable"
	ListStorageOntapInstancesOptions_LifecycleState_Suspended = "suspended"
	ListStorageOntapInstancesOptions_LifecycleState_Updating  = "updating"
	ListStorageOntapInstancesOptions_LifecycleState_Waiting   = "waiting"
)

// NewListStorageOntapInstancesOptions : Instantiate ListStorageOntapInstancesOptions
func (*OntapV1) NewListStorageOntapInstancesOptions() *ListStorageOntapInstancesOptions {
	return &ListStorageOntapInstancesOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListStorageOntapInstancesOptions) SetStart(start string) *ListStorageOntapInstancesOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListStorageOntapInstancesOptions) SetLimit(limit int64) *ListStorageOntapInstancesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (_options *ListStorageOntapInstancesOptions) SetResourceGroupID(resourceGroupID string) *ListStorageOntapInstancesOptions {
	_options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return _options
}

// SetLifecycleState : Allow user to set LifecycleState
func (_options *ListStorageOntapInstancesOptions) SetLifecycleState(lifecycleState string) *ListStorageOntapInstancesOptions {
	_options.LifecycleState = core.StringPtr(lifecycleState)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListStorageOntapInstancesOptions) SetHeaders(param map[string]string) *ListStorageOntapInstancesOptions {
	options.Headers = param
	return options
}

// RefreshCredentialsStorageOntapInstanceOptions : The RefreshCredentialsStorageOntapInstance options.
type RefreshCredentialsStorageOntapInstanceOptions struct {
	// The storage ontap instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRefreshCredentialsStorageOntapInstanceOptions : Instantiate RefreshCredentialsStorageOntapInstanceOptions
func (*OntapV1) NewRefreshCredentialsStorageOntapInstanceOptions(id string) *RefreshCredentialsStorageOntapInstanceOptions {
	return &RefreshCredentialsStorageOntapInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *RefreshCredentialsStorageOntapInstanceOptions) SetID(id string) *RefreshCredentialsStorageOntapInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *RefreshCredentialsStorageOntapInstanceOptions) SetHeaders(param map[string]string) *RefreshCredentialsStorageOntapInstanceOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) will be used.
// Models which "extend" this model:
// - ResourceGroupIdentityByID
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id,omitempty"`
}

func (*ResourceGroupIdentity) isaResourceGroupIdentity() bool {
	return true
}

type ResourceGroupIdentityIntf interface {
	isaResourceGroupIdentity() bool
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : ResourceGroupReference struct
type ResourceGroupReference struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`

	// The name for this resource group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentity : Identifies a routing table by a unique property.
// Models which "extend" this model:
// - RoutingTableIdentityByID
// - RoutingTableIdentityByHref
type RoutingTableIdentity struct {
	// The unique identifier for this routing table.
	ID *string `json:"id,omitempty"`

	// The URL for this routing table.
	Href *string `json:"href,omitempty"`
}

func (*RoutingTableIdentity) isaRoutingTableIdentity() bool {
	return true
}

type RoutingTableIdentityIntf interface {
	isaRoutingTableIdentity() bool
}

// UnmarshalRoutingTableIdentity unmarshals an instance of RoutingTableIdentity from the specified map of raw messages.
func UnmarshalRoutingTableIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableReference : RoutingTableReference struct
type RoutingTableReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *RoutingTableReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// The name for this routing table. The name is unique across all routing tables for the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RoutingTableReference.ResourceType property.
// The resource type.
const (
	RoutingTableReference_ResourceType_RoutingTable = "routing_table"
)

// UnmarshalRoutingTableReference unmarshals an instance of RoutingTableReference from the specified map of raw messages.
func UnmarshalRoutingTableReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalRoutingTableReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type RoutingTableReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalRoutingTableReferenceDeleted unmarshals an instance of RoutingTableReferenceDeleted from the specified map of raw messages.
func UnmarshalRoutingTableReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupIdentityByID
// - SecurityGroupIdentityByCRN
// - SecurityGroupIdentityByHref
type SecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	Crn *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupIdentity) isaSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupIdentityIntf interface {
	isaSecurityGroupIdentity() bool
}

// UnmarshalSecurityGroupIdentity unmarshals an instance of SecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupReference : SecurityGroupReference struct
type SecurityGroupReference struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SecurityGroupReferenceDeleted `json:"deleted,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name for this security group. The name is unique across all security groups for the VPC.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalSecurityGroupReference unmarshals an instance of SecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSecurityGroupReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type SecurityGroupReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalSecurityGroupReferenceDeleted unmarshals an instance of SecurityGroupReferenceDeleted from the specified map of raw messages.
func UnmarshalSecurityGroupReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstance : StorageOntapInstance struct
type StorageOntapInstance struct {
	// An address prefix in the VPC which will be used to allocate `endpoints` for this
	// storage ontap instance and its storage virtual machines.
	AddressPrefix *AddressPrefixReference `json:"address_prefix" validate:"required"`

	// The credentials used (from Secrets Manager) for the cluster administrator to access the
	// storage ontap instance. At least one of `password`, `ssh`, or `http` will be present.
	AdminCredentials *StorageOntapInstanceAdminCredentials `json:"admin_credentials,omitempty"`

	// The capacity to use for the storage ontap instance (in terabytes). Volumes in this storage ontap instance will be
	// allocated from this capacity.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The date and time that the storage ontap instance was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this storage ontap instance.
	Crn *string `json:"crn" validate:"required"`

	// The type of encryption used on the storage ontap instance.
	Encryption *string `json:"encryption" validate:"required"`

	// The root key used to wrap the data encryption key for the storage ontap instance.
	//
	// This property will be present for storage ontap instance with an `encryption` type of
	// `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// The endpoints for this storage ontap instance.
	Endpoints *StorageOntapInstanceEndpoints `json:"endpoints" validate:"required"`

	// The reasons for the current storage ontap instance health_state (if any):
	// - `cluster_down`: This storage ontap instance is unavailable as both the
	//   primary and secondary nodes are unavailable.
	// - `failback_unavailable`: The capability to failback is unavailable. The secondary node
	//   continues to be available.
	// - `failover_unavailable`: The capability to failover is unavailable. The primary
	//   node continues to be available without any performance impact to clients.
	// - `internal_error`: Internal error (contact IBM support).
	// - `maintenance_in_progress`: A planned maintenance activity is in progress.
	// - `primary_node_down`: The primary node is unavailable, and I/O has failed over to
	//   the secondary node. Clients running in the same zone as the primary node may
	//   experience higher access latency.
	// - `secondary_node_down`: The secondary node is unavailable. Therefore, the capability
	//   to failover is unavailable.
	HealthReasons []StorageOntapInstanceHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this storage ontap instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this storage ontap instance.
	ID *string `json:"id" validate:"required"`

	// The reasons for the current `lifecycle_state` (if any).
	//
	// The enumerated reason code values for this property will expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the resource on which the
	// unexpected reason code was encountered.
	LifecycleReasons []StorageOntapInstanceLifecycleReason `json:"lifecycle_reasons" validate:"required"`

	// The lifecycle state of the storage ontap instance.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this storage ontap instance. The name is unique across all storage ontap instances in the region.
	Name *string `json:"name" validate:"required"`

	// The subnet where the primary Cloud Volumes ONTAP node is provisioned in.
	PrimarySubnet *SubnetReference `json:"primary_subnet,omitempty"`

	// The resource group for this storage ontap instance.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The VPC routing tables for this storage ontap instance.
	RoutingTables []RoutingTableReference `json:"routing_tables" validate:"required"`

	// The subnet where the secondary Cloud Volumes ONTAP node is provisioned in.
	SecondarySubnet *SubnetReference `json:"secondary_subnet,omitempty"`

	// The security groups for this storage ontap instance.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The storage virtual machines for this storage ontap instance.
	StorageVirtualMachines []StorageOntapInstanceStorageVirtualMachineReference `json:"storage_virtual_machines" validate:"required"`

	// The VPC this storage ontap instance resides in.
	Vpc *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the StorageOntapInstance.Encryption property.
// The type of encryption used on the storage ontap instance.
const (
	StorageOntapInstance_Encryption_ProviderManaged = "provider_managed"
	StorageOntapInstance_Encryption_UserManaged     = "user_managed"
)

// Constants associated with the StorageOntapInstance.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	StorageOntapInstance_HealthState_Degraded     = "degraded"
	StorageOntapInstance_HealthState_Faulted      = "faulted"
	StorageOntapInstance_HealthState_Inapplicable = "inapplicable"
	StorageOntapInstance_HealthState_Ok           = "ok"
)

// Constants associated with the StorageOntapInstance.LifecycleState property.
// The lifecycle state of the storage ontap instance.
const (
	StorageOntapInstance_LifecycleState_Deleting  = "deleting"
	StorageOntapInstance_LifecycleState_Failed    = "failed"
	StorageOntapInstance_LifecycleState_Pending   = "pending"
	StorageOntapInstance_LifecycleState_Stable    = "stable"
	StorageOntapInstance_LifecycleState_Suspended = "suspended"
	StorageOntapInstance_LifecycleState_Updating  = "updating"
	StorageOntapInstance_LifecycleState_Waiting   = "waiting"
)

// Constants associated with the StorageOntapInstance.ResourceType property.
// The resource type.
const (
	StorageOntapInstance_ResourceType_StorageOntapInstance = "storage_ontap_instance"
)

// UnmarshalStorageOntapInstance unmarshals an instance of StorageOntapInstance from the specified map of raw messages.
func UnmarshalStorageOntapInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstance)
	err = core.UnmarshalModel(m, "address_prefix", &obj.AddressPrefix, UnmarshalAddressPrefixReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "admin_credentials", &obj.AdminCredentials, UnmarshalStorageOntapInstanceAdminCredentials)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "endpoints", &obj.Endpoints, UnmarshalStorageOntapInstanceEndpoints)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalStorageOntapInstanceHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle_reasons", &obj.LifecycleReasons, UnmarshalStorageOntapInstanceLifecycleReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_subnet", &obj.PrimarySubnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_tables", &obj.RoutingTables, UnmarshalRoutingTableReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "secondary_subnet", &obj.SecondarySubnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_virtual_machines", &obj.StorageVirtualMachines, UnmarshalStorageOntapInstanceStorageVirtualMachineReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.Vpc, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceAdminCredentials : The credentials used (from Secrets Manager) for the cluster administrator to access the storage ontap instance. At
// least one of `password`, `ssh`, or `http` will be present.
type StorageOntapInstanceAdminCredentials struct {
	// The security certificate credential for ONTAP REST API access for the cluster
	// administrator of the storage ontap instance.
	Http *CredentialReference `json:"http,omitempty"`

	// The password credential for the cluster administrator of the storage ontap instance.
	//
	// If present, this password credential is used by the cluster administrator for both
	// ONTAP CLI SSH access and ONTAP REST API access. If absent, the storage ontap
	// instance is not accessible through either the ONTAP CLI or ONTAP REST API using
	// password-based authentication.
	Password *CredentialReference `json:"password,omitempty"`

	// The public key credential for ONTAP CLI SSH access for the cluster administrator
	// of the storage ontap instance.
	Ssh *CredentialReference `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceAdminCredentials unmarshals an instance of StorageOntapInstanceAdminCredentials from the specified map of raw messages.
func UnmarshalStorageOntapInstanceAdminCredentials(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceAdminCredentials)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceAdminCredentialsPatch : The credentials to use (from Secrets Manager) for the cluster administrator of the storage ontap instance. At least
// one of `password`, `ssh`, or `http` must be set.
type StorageOntapInstanceAdminCredentialsPatch struct {
	// The security certificate credential to use (from Secrets Manager) for ONTAP REST API
	// access for the cluster administrator of the storage ontap instance. The credential must
	// have the `imported_cert`, `private_cert`, or `public_cert` secret type in Secrets
	// Manager.
	Http CredentialIdentityIntf `json:"http,omitempty"`

	// The password credential to use (from Secrets Manager) for the cluster administrator
	// of the storage ontap instance. The credential must have the `username_password`
	// secret type in Secrets Manager.
	//
	// If specified, this password credential will be used by the cluster administrator for
	// both ONTAP CLI SSH access and ONTAP REST API access. The username specified in
	// this credential must be `ibmss-admin`.
	Password CredentialIdentityIntf `json:"password,omitempty"`

	// The public key credential to use (from Secrets Manager) for ONTAP CLI SSH access
	// for the cluster administrator of the storage ontap instance. The credential must have
	// the `arbitrary` secret type in Secrets Manager.
	Ssh CredentialIdentityIntf `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceAdminCredentialsPatch unmarshals an instance of StorageOntapInstanceAdminCredentialsPatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceAdminCredentialsPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceAdminCredentialsPatch)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceAdminCredentialsPrototype : The credentials to use (from Secrets Manager) for the cluster administrator to access the storage ontap instance. At
// least one of `password`, `ssh`, or `http` must be specified.
type StorageOntapInstanceAdminCredentialsPrototype struct {
	// The security certificate credential to use (from Secrets Manager) for ONTAP REST API
	// access for the cluster administrator of the storage ontap instance. The credential must
	// have the `imported_cert`, `private_cert`, or `public_cert` secret type in Secrets
	// Manager.
	Http CredentialIdentityIntf `json:"http,omitempty"`

	// The password credential to use (from Secrets Manager) for the cluster administrator
	// of the storage ontap instance. The credential must have the `username_password`
	// secret type in Secrets Manager.
	//
	// If specified, this password credential will be used by the cluster administrator for
	// both ONTAP CLI SSH access and ONTAP REST API access. The username specified in
	// this credential must be `ibmss-admin`.
	Password CredentialIdentityIntf `json:"password,omitempty"`

	// The public key credential to use (from Secrets Manager) for ONTAP CLI SSH access
	// for the cluster administrator of the storage ontap instance. The credential must have
	// the `arbitrary` secret type in Secrets Manager.
	Ssh CredentialIdentityIntf `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceAdminCredentialsPrototype unmarshals an instance of StorageOntapInstanceAdminCredentialsPrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceAdminCredentialsPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceAdminCredentialsPrototype)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceCollection : StorageOntapInstanceCollection struct
type StorageOntapInstanceCollection struct {
	// A link to the first page of resources.
	First *StorageOntapInstanceCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *StorageOntapInstanceCollectionNext `json:"next,omitempty"`

	// Collection of storage ontap instances.
	StorageOntapInstances []StorageOntapInstance `json:"storage_ontap_instances" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalStorageOntapInstanceCollection unmarshals an instance of StorageOntapInstanceCollection from the specified map of raw messages.
func UnmarshalStorageOntapInstanceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalStorageOntapInstanceCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalStorageOntapInstanceCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_ontap_instances", &obj.StorageOntapInstances, UnmarshalStorageOntapInstance)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *StorageOntapInstanceCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// StorageOntapInstanceCollectionFirst : A link to the first page of resources.
type StorageOntapInstanceCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceCollectionFirst unmarshals an instance of StorageOntapInstanceCollectionFirst from the specified map of raw messages.
func UnmarshalStorageOntapInstanceCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type StorageOntapInstanceCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceCollectionNext unmarshals an instance of StorageOntapInstanceCollectionNext from the specified map of raw messages.
func UnmarshalStorageOntapInstanceCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceEndpoint : StorageOntapInstanceEndpoint struct
type StorageOntapInstanceEndpoint struct {
	// The unique IP address of an endpoint.
	Ipv4Address *string `json:"ipv4_address" validate:"required"`
}

// UnmarshalStorageOntapInstanceEndpoint unmarshals an instance of StorageOntapInstanceEndpoint from the specified map of raw messages.
func UnmarshalStorageOntapInstanceEndpoint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceEndpoint)
	err = core.UnmarshalPrimitive(m, "ipv4_address", &obj.Ipv4Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceEndpoints : StorageOntapInstanceEndpoints struct
type StorageOntapInstanceEndpoints struct {
	// The NetApp SnapMirror management endpoint for this storage ontap instance.
	InterCluster *StorageOntapInstanceEndpoint `json:"inter_cluster" validate:"required"`

	// The NetApp management endpoint for this storage ontap instance. Management may be
	// performed using the ONTAP CLI, ONTAP API, or NetApp CloudManager.
	Management *StorageOntapInstanceEndpoint `json:"management" validate:"required"`
}

// UnmarshalStorageOntapInstanceEndpoints unmarshals an instance of StorageOntapInstanceEndpoints from the specified map of raw messages.
func UnmarshalStorageOntapInstanceEndpoints(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceEndpoints)
	err = core.UnmarshalModel(m, "inter_cluster", &obj.InterCluster, UnmarshalStorageOntapInstanceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "management", &obj.Management, UnmarshalStorageOntapInstanceEndpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceHealthReason : StorageOntapInstanceHealthReason struct
type StorageOntapInstanceHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the StorageOntapInstanceHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	StorageOntapInstanceHealthReason_Code_ClusterDown           = "cluster_down"
	StorageOntapInstanceHealthReason_Code_FailbackUnavailable   = "failback_unavailable"
	StorageOntapInstanceHealthReason_Code_FailoverUnavailable   = "failover_unavailable"
	StorageOntapInstanceHealthReason_Code_InternalError         = "internal_error"
	StorageOntapInstanceHealthReason_Code_MaintenanceInProgress = "maintenance_in_progress"
	StorageOntapInstanceHealthReason_Code_PrimaryNodeDown       = "primary_node_down"
	StorageOntapInstanceHealthReason_Code_SecondaryNodeDown     = "secondary_node_down"
)

// UnmarshalStorageOntapInstanceHealthReason unmarshals an instance of StorageOntapInstanceHealthReason from the specified map of raw messages.
func UnmarshalStorageOntapInstanceHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceLifecycleReason : StorageOntapInstanceLifecycleReason struct
type StorageOntapInstanceLifecycleReason struct {
	// A snake case string succinctly identifying the reason for this lifecycle state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this lifecycle state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this lifecycle state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the StorageOntapInstanceLifecycleReason.Code property.
// A snake case string succinctly identifying the reason for this lifecycle state.
const (
	StorageOntapInstanceLifecycleReason_Code_ResourceSuspendedByProvider = "resource_suspended_by_provider"
)

// UnmarshalStorageOntapInstanceLifecycleReason unmarshals an instance of StorageOntapInstanceLifecycleReason from the specified map of raw messages.
func UnmarshalStorageOntapInstanceLifecycleReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceLifecycleReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstancePatch : StorageOntapInstancePatch struct
type StorageOntapInstancePatch struct {
	// The credentials to use (from Secrets Manager) for the cluster administrator of the storage
	// ontap instance. At least one of `password`, `ssh`, or `http` must be set.
	AdminCredentials *StorageOntapInstanceAdminCredentialsPatch `json:"admin_credentials,omitempty"`

	// The capacity to use for the storage ontap instance (in terabytes). The specified value must not be less than the
	// current capacity.
	Capacity *int64 `json:"capacity,omitempty"`

	// The name for this storage ontap instance. The name must not be used by another storage ontap instance in the region.
	Name *string `json:"name,omitempty"`

	// The VPC routing tables to use for this storage ontap instance. Routes will be added by the service in these routing
	// tables to allow virtual server instances to access the endpoints of this storage ontap instance.
	RoutingTables []RoutingTableIdentityIntf `json:"routing_tables,omitempty"`
}

// UnmarshalStorageOntapInstancePatch unmarshals an instance of StorageOntapInstancePatch from the specified map of raw messages.
func UnmarshalStorageOntapInstancePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstancePatch)
	err = core.UnmarshalModel(m, "admin_credentials", &obj.AdminCredentials, UnmarshalStorageOntapInstanceAdminCredentialsPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_tables", &obj.RoutingTables, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the StorageOntapInstancePatch
func (storageOntapInstancePatch *StorageOntapInstancePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(storageOntapInstancePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// StorageOntapInstanceStorageVirtualMachine : StorageOntapInstanceStorageVirtualMachine struct
type StorageOntapInstanceStorageVirtualMachine struct {
	// The Active Directory service this storage virtual machine is joined to.
	//
	// If absent, this storage virtual machine is not joined to an Active Directory service.
	ActiveDirectory *StorageOntapInstanceStorageVirtualMachineActiveDirectory `json:"active_directory,omitempty"`

	// The credentials used for the administrator to access the storage virtual machine of the
	// storage ontap instance. At least one of `password`, `ssh`, or `http` will be present.
	AdminCredentials *StorageOntapInstanceStorageVirtualMachineAdminCredentials `json:"admin_credentials,omitempty"`

	// The date and time that the storage virtual machine was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The data and management endpoints for this storage virtual machine.
	Endpoints *StorageOntapInstanceStorageVirtualMachineEndpoints `json:"endpoints" validate:"required"`

	// The URL for this storage virtual machine.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this storage virtual machine.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the storage virtual machine.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this storage virtual machine. The name is unique across all storage virtual machines in the storage
	// ontap instance.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachine.LifecycleState property.
// The lifecycle state of the storage virtual machine.
const (
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Deleting  = "deleting"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Failed    = "failed"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Pending   = "pending"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Stable    = "stable"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Suspended = "suspended"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Updating  = "updating"
	StorageOntapInstanceStorageVirtualMachine_LifecycleState_Waiting   = "waiting"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachine.ResourceType property.
// The resource type.
const (
	StorageOntapInstanceStorageVirtualMachine_ResourceType_StorageOntapInstanceStorageVirtualMachine = "storage_ontap_instance_storage_virtual_machine"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachine unmarshals an instance of StorageOntapInstanceStorageVirtualMachine from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachine(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachine)
	err = core.UnmarshalModel(m, "active_directory", &obj.ActiveDirectory, UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "admin_credentials", &obj.AdminCredentials, UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentials)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "endpoints", &obj.Endpoints, UnmarshalStorageOntapInstanceStorageVirtualMachineEndpoints)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineActiveDirectory : StorageOntapInstanceStorageVirtualMachineActiveDirectory struct
type StorageOntapInstanceStorageVirtualMachineActiveDirectory struct {
	// The name of the domain group whose members have been granted administrative privileges for this storage virtual
	// machine.
	AdministratorsGroup *string `json:"administrators_group" validate:"required"`

	// The IP addresses of the Active Directory DNS servers or domain controllers.
	DnsIps []string `json:"dns_ips" validate:"required"`

	// The fully qualified domain name of the self-managed Active Directory.
	DomainName *string `json:"domain_name" validate:"required"`

	// The password credential for the Active Directory domain.
	DomainPasswordCredential *CredentialReference `json:"domain_password_credential,omitempty"`

	// The name of the Active Directory computer object that will be created for the storage virtual machine.
	NetbiosName *string `json:"netbios_name" validate:"required"`

	// The distinguished name of the organizational unit within the self-managed Active Directory.
	OrganizationalUnitDistinguishedName *string `json:"organizational_unit_distinguished_name" validate:"required"`

	// The username that this storage virtual machine will use when joining the Active Directory domain. This username will
	// be the same as the username credential used in `domain_password_credential`.
	Username *string `json:"username" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectory unmarshals an instance of StorageOntapInstanceStorageVirtualMachineActiveDirectory from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineActiveDirectory)
	err = core.UnmarshalPrimitive(m, "administrators_group", &obj.AdministratorsGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dns_ips", &obj.DnsIps)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain_name", &obj.DomainName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "domain_password_credential", &obj.DomainPasswordCredential, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "netbios_name", &obj.NetbiosName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "organizational_unit_distinguished_name", &obj.OrganizationalUnitDistinguishedName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch : StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch struct
type StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch struct {
	// The name of the domain group whose members have been granted administrative privileges for this storage virtual
	// machine.
	AdministratorsGroup *string `json:"administrators_group,omitempty"`

	// The IP addresses of the Active Directory DNS servers or domain controllers.
	DnsIps []string `json:"dns_ips,omitempty"`

	// The fully qualified domain name of the self-managed Active Directory.
	DomainName *string `json:"domain_name,omitempty"`

	// The password credential to use (from Secrets Manager) for the Active Directory domain.
	// The secret must be of type `username_password`. The username credential specified in
	// Secrets Manager must be the same as `username`.
	DomainPasswordCredential CredentialIdentityIntf `json:"domain_password_credential,omitempty"`

	// The name of the Active Directory computer object that will be created for the storage virtual machine.
	NetbiosName *string `json:"netbios_name,omitempty"`

	// The distinguished name of the organizational unit within the self-managed Active Directory.
	OrganizationalUnitDistinguishedName *string `json:"organizational_unit_distinguished_name,omitempty"`

	// The username that this storage virtual machine will use when joining the Active Directory domain. This username will
	// be the same as the username credential used in `domain_password_credential`.
	Username *string `json:"username,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch)
	err = core.UnmarshalPrimitive(m, "administrators_group", &obj.AdministratorsGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dns_ips", &obj.DnsIps)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain_name", &obj.DomainName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "domain_password_credential", &obj.DomainPasswordCredential, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "netbios_name", &obj.NetbiosName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "organizational_unit_distinguished_name", &obj.OrganizationalUnitDistinguishedName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype : StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype struct
type StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype struct {
	// The name of the domain group whose members have been granted administrative privileges for this storage virtual
	// machine.
	AdministratorsGroup *string `json:"administrators_group" validate:"required"`

	// The IP addresses of the Active Directory DNS servers or domain controllers.
	DnsIps []string `json:"dns_ips" validate:"required"`

	// The fully qualified domain name of the self-managed Active Directory.
	DomainName *string `json:"domain_name" validate:"required"`

	// The password credential to use (from Secrets Manager) for the Active Directory domain.
	// The secret must be of type `username_password`. The username credential specified in
	// Secrets Manager must be the same as `username`.
	DomainPasswordCredential CredentialIdentityIntf `json:"domain_password_credential,omitempty"`

	// The name of the Active Directory computer object that will be created for the storage virtual machine.
	NetbiosName *string `json:"netbios_name" validate:"required"`

	// The distinguished name of the organizational unit within the self-managed Active Directory.
	OrganizationalUnitDistinguishedName *string `json:"organizational_unit_distinguished_name" validate:"required"`

	// The username that this storage virtual machine will use when joining the Active Directory domain. This username will
	// be the same as the username credential used in `domain_password_credential`.
	Username *string `json:"username" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype : Instantiate StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype(administratorsGroup string, dnsIps []string, domainName string, netbiosName string, organizationalUnitDistinguishedName string, username string) (_model *StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype{
		AdministratorsGroup:                 core.StringPtr(administratorsGroup),
		DnsIps:                              dnsIps,
		DomainName:                          core.StringPtr(domainName),
		NetbiosName:                         core.StringPtr(netbiosName),
		OrganizationalUnitDistinguishedName: core.StringPtr(organizationalUnitDistinguishedName),
		Username:                            core.StringPtr(username),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype)
	err = core.UnmarshalPrimitive(m, "administrators_group", &obj.AdministratorsGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dns_ips", &obj.DnsIps)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain_name", &obj.DomainName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "domain_password_credential", &obj.DomainPasswordCredential, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "netbios_name", &obj.NetbiosName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "organizational_unit_distinguished_name", &obj.OrganizationalUnitDistinguishedName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "username", &obj.Username)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineAdminCredentials : The credentials used for the administrator to access the storage virtual machine of the storage ontap instance. At
// least one of `password`, `ssh`, or `http` will be present.
type StorageOntapInstanceStorageVirtualMachineAdminCredentials struct {
	// The security certificate credential for ONTAP REST API access for the storage virtual
	// machine administrator.
	Http *CredentialReference `json:"http,omitempty"`

	// The password credential for the storage virtual machine administrator.
	//
	// If present, this password credential is used by the storage virtual machine
	// administrator for both ONTAP CLI SSH access and ONTAP REST API access.
	// If absent, the storage virtual machine is not accessible through either the ONTAP CLI
	// or ONTAP REST API using password-based authentication.
	Password *CredentialReference `json:"password,omitempty"`

	// The public key credential for ONTAP CLI based ssh login for the storage virtual
	// machine administrator.
	Ssh *CredentialReference `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentials unmarshals an instance of StorageOntapInstanceStorageVirtualMachineAdminCredentials from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentials(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineAdminCredentials)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch : The credentials to use (from Secrets Manager) for the administrator to access the storage virtual machine of the
// storage ontap instance. At least one of `password`, `ssh`, or
// `http` must be set.
type StorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch struct {
	// The security certificate credential to use (from Secrets Manager) for ONTAP REST API
	// access for the storage virtual machine administrator. The credential must have the
	// `imported_cert`, `private_cert`, or `public_cert` secret type in Secrets Manager.
	Http CredentialIdentityIntf `json:"http,omitempty"`

	// The password credential to use (from Secrets Manager) for the storage virtual machine
	// administrator. This credential must have the `username_password` secret type in
	// Secrets Manager.
	//
	// If specified, this password credential will be used by the storage virtual machine
	// administrator for both ONTAP CLI SSH access and ONTAP REST API access.
	// The username specified in this credential must be `ibmss-svmadmin`.
	Password CredentialIdentityIntf `json:"password,omitempty"`

	// The public key credential to use (from Secrets Manager) for ONTAP CLI SSH access
	// for the storage virtual machine administrator. The credential must have the `arbitrary`
	// secret type in Secrets Manager.
	Ssh CredentialIdentityIntf `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype : The credentials to use (from Secrets Manager) for the administrator to access the storage virtual machine of the
// storage ontap instance. At least one of `password`, `ssh`, or
// `http` must be specified.
type StorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype struct {
	// The security certificate credential to use (from Secrets Manager) for ONTAP REST API
	// access for the storage virtual machine administrator. The credential must have the
	// `imported_cert`, `private_cert`, or `public_cert` secret type in Secrets Manager.
	Http CredentialIdentityIntf `json:"http,omitempty"`

	// The password credential to use (from Secrets Manager) for the storage virtual machine
	// administrator. This credential must have the `username_password` secret type in
	// Secrets Manager.
	//
	// If specified, this password credential will be used by the storage virtual machine
	// administrator for both ONTAP CLI SSH access and ONTAP REST API access.
	// The username specified in this credential must be `ibmss-svmadmin`.
	Password CredentialIdentityIntf `json:"password,omitempty"`

	// The public key credential to use (from Secrets Manager) for ONTAP CLI SSH access
	// for the storage virtual machine administrator. The credential must have the `arbitrary`
	// secret type in Secrets Manager.
	Ssh CredentialIdentityIntf `json:"ssh,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype)
	err = core.UnmarshalModel(m, "http", &obj.Http, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ssh", &obj.Ssh, UnmarshalCredentialIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineCollection : StorageOntapInstanceStorageVirtualMachineCollection struct
type StorageOntapInstanceStorageVirtualMachineCollection struct {
	// A link to the first page of resources.
	First *StorageOntapInstanceStorageVirtualMachineCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *StorageOntapInstanceStorageVirtualMachineCollectionNext `json:"next,omitempty"`

	// Collection of storage virtual machines.
	StorageVirtualMachines []StorageOntapInstanceStorageVirtualMachine `json:"storage_virtual_machines" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineCollection unmarshals an instance of StorageOntapInstanceStorageVirtualMachineCollection from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_virtual_machines", &obj.StorageVirtualMachines, UnmarshalStorageOntapInstanceStorageVirtualMachine)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *StorageOntapInstanceStorageVirtualMachineCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// StorageOntapInstanceStorageVirtualMachineCollectionFirst : A link to the first page of resources.
type StorageOntapInstanceStorageVirtualMachineCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionFirst unmarshals an instance of StorageOntapInstanceStorageVirtualMachineCollectionFirst from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type StorageOntapInstanceStorageVirtualMachineCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionNext unmarshals an instance of StorageOntapInstanceStorageVirtualMachineCollectionNext from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineEndpoints : StorageOntapInstanceStorageVirtualMachineEndpoints struct
type StorageOntapInstanceStorageVirtualMachineEndpoints struct {
	// The NetApp management endpoint for this storage virtual machine. Management may be
	// performed using the ONTAP CLI, ONTAP API, or NetApp CloudManager.
	Management *StorageOntapInstanceEndpoint `json:"management" validate:"required"`

	// The Network File System (NFS) protocol endpoint for this storage virtual machine.
	//
	// If absent, NFS is not enabled on this storage virtual machine.
	Nfs *StorageOntapInstanceEndpoint `json:"nfs,omitempty"`

	// The Server Message Block (SMB) protocol endpoint for this storage virtual machine.
	//
	// If absent, SMB is not enabled on this storage virtual machine.
	Smb *StorageOntapInstanceEndpoint `json:"smb,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineEndpoints unmarshals an instance of StorageOntapInstanceStorageVirtualMachineEndpoints from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineEndpoints(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineEndpoints)
	err = core.UnmarshalModel(m, "management", &obj.Management, UnmarshalStorageOntapInstanceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "nfs", &obj.Nfs, UnmarshalStorageOntapInstanceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "smb", &obj.Smb, UnmarshalStorageOntapInstanceEndpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachinePatch : StorageOntapInstanceStorageVirtualMachinePatch struct
type StorageOntapInstanceStorageVirtualMachinePatch struct {
	// The Active Directory service to join this storage virtual machine to. If the storage
	// virtual machine is not currently joined to an Active Directory service and the
	// `security_style` is being set to `windows` or `mixed`, all properties must be
	// specified.
	//
	// Specify `null` to remove any existing Active Directory configuration.
	ActiveDirectory *StorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch `json:"active_directory,omitempty"`

	// The credentials to use (from Secrets Manager) for the administrator to access the storage
	// virtual machine of the storage ontap instance. At least one of `password`, `ssh`, or
	// `http` must be set.
	AdminCredentials *StorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch `json:"admin_credentials,omitempty"`

	// The name for this storage virtual machine. The name must be unique across all storage virtual machines in the
	// storage ontap instance.
	Name *string `json:"name,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachinePatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachinePatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachinePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachinePatch)
	err = core.UnmarshalModel(m, "active_directory", &obj.ActiveDirectory, UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "admin_credentials", &obj.AdminCredentials, UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the StorageOntapInstanceStorageVirtualMachinePatch
func (storageOntapInstanceStorageVirtualMachinePatch *StorageOntapInstanceStorageVirtualMachinePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(storageOntapInstanceStorageVirtualMachinePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// StorageOntapInstanceStorageVirtualMachinePrototype : StorageOntapInstanceStorageVirtualMachinePrototype struct
type StorageOntapInstanceStorageVirtualMachinePrototype struct {
	// The Active Directory service to join this storage virtual machine to.
	//
	// This must be specified if `security_style` is `windows` or `mixed`.
	ActiveDirectory *StorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype `json:"active_directory,omitempty"`

	// The credentials to use (from Secrets Manager) for the administrator to access the storage
	// virtual machine of the storage ontap instance. At least one of `password`, `ssh`, or
	// `http` must be specified.
	AdminCredentials *StorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype `json:"admin_credentials,omitempty"`

	// The name for this storage virtual machine. The name must be unique across all storage virtual machines in the
	// storage ontap instance.
	//
	// If unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachinePrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachinePrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachinePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachinePrototype)
	err = core.UnmarshalModel(m, "active_directory", &obj.ActiveDirectory, UnmarshalStorageOntapInstanceStorageVirtualMachineActiveDirectoryPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "admin_credentials", &obj.AdminCredentials, UnmarshalStorageOntapInstanceStorageVirtualMachineAdminCredentialsPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineReference : StorageOntapInstanceStorageVirtualMachineReference struct
type StorageOntapInstanceStorageVirtualMachineReference struct {
	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *StorageOntapInstanceStorageVirtualMachineReferenceDeleted `json:"deleted,omitempty"`

	// The URL for this storage virtual machine.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this storage virtual machine.
	ID *string `json:"id" validate:"required"`

	// The name for this storage virtual machine. The name is unique across all storage virtual machines in the storage
	// ontap instance.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineReference.ResourceType property.
// The resource type.
const (
	StorageOntapInstanceStorageVirtualMachineReference_ResourceType_StorageOntapInstanceStorageVirtualMachine = "storage_ontap_instance_storage_virtual_machine"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineReference unmarshals an instance of StorageOntapInstanceStorageVirtualMachineReference from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineReference)
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalStorageOntapInstanceStorageVirtualMachineReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type StorageOntapInstanceStorageVirtualMachineReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineReferenceDeleted unmarshals an instance of StorageOntapInstanceStorageVirtualMachineReferenceDeleted from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolume : StorageOntapInstanceStorageVirtualMachineVolume struct
type StorageOntapInstanceStorageVirtualMachineVolume struct {
	// The capacity of the storage volume (in gigabytes).
	Capacity *int64 `json:"capacity" validate:"required"`

	// The named access point that enables CIFS clients to view, browse, and manipulate
	// files on this storage volume
	//
	// This will be present when `security_style` is `mixed` or `windows`.
	CifsShare *StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare `json:"cifs_share,omitempty"`

	// The date and time that the storage volume was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Indicates whether storage efficiency is enabled for the storage volume.
	//
	// If `true`, data-deduplication, compression and other efficiencies for space-management are enabled for this volume.
	// Deprecated: this field is deprecated and may be removed in a future release.
	EnableStorageEfficiency *bool `json:"enable_storage_efficiency,omitempty"`

	// The NFS export policy for the storage volume.
	//
	// This will be present when `security_style` is `mixed` or `unix`.
	ExportPolicy *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy `json:"export_policy,omitempty"`

	// The reasons for the current storage volume health_state (if any):
	// - `primary_node_down`: The storage volume is experiencing higher latency due to
	//   the primary node being unavailable, and I/O being routed to the secondary node.
	// - `volume_unavailable`: The storage volume is unavailable as both the primary and secondary nodes are down.
	// - `internal_error`: Internal error (contact IBM support).
	HealthReasons []StorageOntapInstanceStorageVirtualMachineVolumeHealthReason `json:"health_reasons" validate:"required"`

	// The health of this resource.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// The URL for this storage volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this storage volume.
	ID *string `json:"id" validate:"required"`

	// The path clients can use to mount or access this storage volume. The path is case insensitive and is unique within a
	// storage virtual machine.
	JunctionPath *string `json:"junction_path" validate:"required"`

	// The lifecycle state of the storage volume.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name for this storage volume. The name is unique across all storage volumes in the storage virtual machine.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The security style for the storage volume:
	// - `unix`: NFS clients can access the storage volume.
	// - `windows`: SMB/CIFS clients can access the storage volume.
	// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
	// - `none`: No clients can access the volume.
	SecurityStyle *string `json:"security_style" validate:"required"`

	// The storage efficiency mode used for this storage volume.
	// - `disabled`: storage efficiency methods will not be used
	// - `enabled`: data-deduplication, compression and other methods will be used.
	StorageEfficiency *string `json:"storage_efficiency,omitempty"`

	// The type of the storage volume.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.HealthState property.
// The health of this resource.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_HealthState_Degraded     = "degraded"
	StorageOntapInstanceStorageVirtualMachineVolume_HealthState_Faulted      = "faulted"
	StorageOntapInstanceStorageVirtualMachineVolume_HealthState_Inapplicable = "inapplicable"
	StorageOntapInstanceStorageVirtualMachineVolume_HealthState_Ok           = "ok"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.LifecycleState property.
// The lifecycle state of the storage volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Deleting  = "deleting"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Failed    = "failed"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Pending   = "pending"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Stable    = "stable"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Suspended = "suspended"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Updating  = "updating"
	StorageOntapInstanceStorageVirtualMachineVolume_LifecycleState_Waiting   = "waiting"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.ResourceType property.
// The resource type.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_ResourceType_StorageOntapInstanceStorageVirtualMachineVolume = "storage_ontap_instance_storage_virtual_machine_volume"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.SecurityStyle property.
// The security style for the storage volume:
// - `unix`: NFS clients can access the storage volume.
// - `windows`: SMB/CIFS clients can access the storage volume.
// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
// - `none`: No clients can access the volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_SecurityStyle_Mixed   = "mixed"
	StorageOntapInstanceStorageVirtualMachineVolume_SecurityStyle_None    = "none"
	StorageOntapInstanceStorageVirtualMachineVolume_SecurityStyle_Unix    = "unix"
	StorageOntapInstanceStorageVirtualMachineVolume_SecurityStyle_Windows = "windows"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.StorageEfficiency property.
// The storage efficiency mode used for this storage volume.
// - `disabled`: storage efficiency methods will not be used
// - `enabled`: data-deduplication, compression and other methods will be used.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_StorageEfficiency_Disabled = "disabled"
	StorageOntapInstanceStorageVirtualMachineVolume_StorageEfficiency_Enabled  = "enabled"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolume.Type property.
// The type of the storage volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolume_Type_DataProtection = "data_protection"
	StorageOntapInstanceStorageVirtualMachineVolume_Type_ReadWrite      = "read_write"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolume unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolume from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolume)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cifs_share", &obj.CifsShare, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShare)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_storage_efficiency", &obj.EnableStorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "export_policy", &obj.ExportPolicy, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_reasons", &obj.HealthReasons, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeHealthReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "junction_path", &obj.JunctionPath)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_style", &obj.SecurityStyle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage_efficiency", &obj.StorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare : StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare struct
type StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare struct {
	// The access control list for the CIFS share.
	AccessControlList []StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl `json:"access_control_list" validate:"required"`

	// The SMB/CIFS mount point for the storage volume.
	MountPath *string `json:"mount_path" validate:"required"`

	// The share name registered in Active Directory that SMB/CIFS clients use to mount the share. The name is unique
	// within the Active Directory domain.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShare unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShare(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCIFSShare)
	err = core.UnmarshalModel(m, "access_control_list", &obj.AccessControlList, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mount_path", &obj.MountPath)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl : StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl struct
type StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl struct {
	// The permission granted to users matching this access control list entry.
	Permission *string `json:"permission" validate:"required"`

	// The users matching this access control list entry.
	Users []string `json:"users" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl.Permission property.
// The permission granted to users matching this access control list entry.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl_Permission_Change      = "change"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl_Permission_FullControl = "full_control"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl_Permission_NoAccess    = "no_access"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl_Permission_Read        = "read"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControl)
	err = core.UnmarshalPrimitive(m, "permission", &obj.Permission)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "users", &obj.Users)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype : StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype struct
type StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype struct {
	// The permission to grant to users matching this access control list entry.
	Permission *string `json:"permission" validate:"required"`

	// The users to match this access control list entry.
	Users []string `json:"users" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype.Permission property.
// The permission to grant to users matching this access control list entry.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype_Permission_Change      = "change"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype_Permission_FullControl = "full_control"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype_Permission_NoAccess    = "no_access"
	StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype_Permission_Read        = "read"
)

// NewStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype(permission string, users []string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype{
		Permission: core.StringPtr(permission),
		Users:      users,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype)
	err = core.UnmarshalPrimitive(m, "permission", &obj.Permission)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "users", &obj.Users)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch : StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch struct
type StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch struct {
	// The access control list for the CIFS share (replacing any existing access control list). A user may not be specified
	// in more than one access control list entry.
	AccessControlList []StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype `json:"access_control_list,omitempty"`

	// The share name to register in Active Directory that SMB/CIFS clients will use to mount the share. The name must be
	// unique within the Active Directory domain.
	Name *string `json:"name,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch)
	err = core.UnmarshalModel(m, "access_control_list", &obj.AccessControlList, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype : StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype struct
type StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype struct {
	// The access control list for the CIFS share. A user may not be specified in more than one access control list entry.
	AccessControlList []StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype `json:"access_control_list" validate:"required"`

	// The share name to register in Active Directory that SMB/CIFS clients will use to mount the share. The name must be
	// unique within the Active Directory domain.
	Name *string `json:"name" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype(accessControlList []StorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype, name string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype{
		AccessControlList: accessControlList,
		Name:              core.StringPtr(name),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype)
	err = core.UnmarshalModel(m, "access_control_list", &obj.AccessControlList, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSShareAccessControlPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCollection : StorageOntapInstanceStorageVirtualMachineVolumeCollection struct
type StorageOntapInstanceStorageVirtualMachineVolumeCollection struct {
	// A link to the first page of resources.
	First *StorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A link to the next page of resources. This property is present for all pages
	// except the last page.
	Next *StorageOntapInstanceStorageVirtualMachineVolumeCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of storage volumes.
	Volumes []StorageOntapInstanceStorageVirtualMachineVolume `json:"volumes" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollection unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCollection from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalStorageOntapInstanceStorageVirtualMachineVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *StorageOntapInstanceStorageVirtualMachineVolumeCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil || start == nil {
		return nil, err
	}
	return start, nil
}

// StorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst : A link to the first page of resources.
type StorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeCollectionNext : A link to the next page of resources. This property is present for all pages except the last page.
type StorageOntapInstanceStorageVirtualMachineVolumeCollectionNext struct {
	// The URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionNext unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeCollectionNext from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy struct
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy struct {
	// The NFS mount point for the storage volume.
	MountPath *string `json:"mount_path" validate:"required"`

	// The NFS export policy rules for this storage volume.
	//
	// Only NFS clients included in the rules will access the volume, and only according to the specified access controls
	// and NFS protocol versions.
	Rules []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule `json:"rules,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicy unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicy)
	err = core.UnmarshalPrimitive(m, "mount_path", &obj.MountPath)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch struct
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch struct {
	// The NFS export policy rules to use for this storage volume, replacing any existing rules.
	//
	// Only NFS clients included in the rules may access the volume, and only according to the specified access controls
	// and NFS protocol versions. The same client cannot be part of more than one rule.
	Rules []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype `json:"rules,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype struct
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype struct {
	// The NFS export policy rules to use for this storage volume.
	//
	// Only NFS clients included in the rules may access the volume, and only according to the specified access controls
	// and NFS protocol versions. The same client cannot be part of more than one rule.
	Rules []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype `json:"rules,omitempty"`
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule struct
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule struct {
	// The access control that is provided to clients that match this rule.
	AccessControl *string `json:"access_control" validate:"required"`

	// The clients that match this rule. Every client in the list of `clients` is unique.
	Clients []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientIntf `json:"clients" validate:"required"`

	// The unique index for this rule. Rules are applied from lowest to highest index.
	Index *int64 `json:"index" validate:"required"`

	// If `true`, clients matching this rule that request super-user access are honored. Otherwise, clients are mapped to
	// the anonymous user.
	IsSuperuser *bool `json:"is_superuser" validate:"required"`

	// The NFS versions that is provided to clients that match this rule.
	NfsVersion []string `json:"nfs_version" validate:"required"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule.AccessControl property.
// The access control that is provided to clients that match this rule.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule_AccessControl_None      = "none"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule_AccessControl_ReadOnly  = "read_only"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule_AccessControl_ReadWrite = "read_write"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule.NfsVersion property.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule_NfsVersion_Nfs3 = "nfs3"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule_NfsVersion_Nfs4 = "nfs4"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRule)
	err = core.UnmarshalPrimitive(m, "access_control", &obj.AccessControl)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clients", &obj.Clients, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "index", &obj.Index)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_superuser", &obj.IsSuperuser)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nfs_version", &obj.NfsVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient : The NFS client may be specified as:
// - A hostname (such as`host1`)
// - An IPv4 address (such as`10.1.12.24`)
// - An IPv4 CIDR block (such as `10.1.12.0/24`)
// - A domain name suffix (such as `.example.com`).
// Models which "extend" this model:
// - StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname
// - StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP
// - StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR
// - StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient struct {
	// The hostname of the NFS client.
	Hostname *string `json:"hostname,omitempty"`

	// The IP address of the NFS client.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block containing IP addresses of the NFS clients. The CIDR block `0.0.0.0/0` matches all client addresses.
	//
	// This property may add support for IPv6 CIDR blocks in the future. When processing a value in this property, verify
	// that the CIDR block is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block,omitempty"`

	// The domain names suffixes of the NFS clients.
	DomainSuffix *string `json:"domain_suffix,omitempty"`
}

func (*StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient) isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool {
	return true
}

type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientIntf interface {
	isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient)
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CidrBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain_suffix", &obj.DomainSuffix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype struct
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype struct {
	// The access control that will be provided to clients that match this rule.
	AccessControl *string `json:"access_control,omitempty"`

	// The clients that will match this rule.
	Clients []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientIntf `json:"clients" validate:"required"`

	// If `true`, clients matching this rule that request super-user access will be honored. Otherwise, clients will be
	// mapped to the anonymous user.
	IsSuperuser *bool `json:"is_superuser,omitempty"`

	// The NFS versions that will be provided to clients that match this rule.
	NfsVersion []string `json:"nfs_version,omitempty"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype.AccessControl property.
// The access control that will be provided to clients that match this rule.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype_AccessControl_None      = "none"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype_AccessControl_ReadOnly  = "read_only"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype_AccessControl_ReadWrite = "read_write"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype.NfsVersion property.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype_NfsVersion_Nfs3 = "nfs3"
	StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype_NfsVersion_Nfs4 = "nfs4"
)

// NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype(clients []StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientIntf) (_model *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype{
		Clients: clients,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRulePrototype)
	err = core.UnmarshalPrimitive(m, "access_control", &obj.AccessControl)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clients", &obj.Clients, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_superuser", &obj.IsSuperuser)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nfs_version", &obj.NfsVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeHealthReason : StorageOntapInstanceStorageVirtualMachineVolumeHealthReason struct
type StorageOntapInstanceStorageVirtualMachineVolumeHealthReason struct {
	// A snake case string succinctly identifying the reason for this health state.
	Code *string `json:"code" validate:"required"`

	// An explanation of the reason for this health state.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about the reason for this health state.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumeHealthReason.Code property.
// A snake case string succinctly identifying the reason for this health state.
const (
	StorageOntapInstanceStorageVirtualMachineVolumeHealthReason_Code_InternalError     = "internal_error"
	StorageOntapInstanceStorageVirtualMachineVolumeHealthReason_Code_PrimaryNodeDown   = "primary_node_down"
	StorageOntapInstanceStorageVirtualMachineVolumeHealthReason_Code_VolumeUnavailable = "volume_unavailable"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeHealthReason unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeHealthReason from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeHealthReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeHealthReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumePatch : StorageOntapInstanceStorageVirtualMachineVolumePatch struct
type StorageOntapInstanceStorageVirtualMachineVolumePatch struct {
	// The capacity to use for the storage volume (in gigabytes). The specified value must not be less than the current
	// capacity.
	Capacity *int64 `json:"capacity,omitempty"`

	// The named access point that enables CIFS clients to view, browse, and manipulate
	// files on this storage volume.
	//
	// This must be specified if security_style is `mixed` or `windows`.
	CifsShare *StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch `json:"cifs_share,omitempty"`

	// The NFS export policy for the storage volume.
	//
	// This must be set if `security_style` is `mixed` or `unix`.
	ExportPolicy *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch `json:"export_policy,omitempty"`

	// The name for this storage volume. The name must be unique across all storage volumes in the storage virtual machine.
	Name *string `json:"name,omitempty"`

	// The security style for the storage volume:
	// - `unix`: NFS clients can access the storage volume.
	// - `windows`: SMB/CIFS clients can access the storage volume.
	// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
	// - `none`: No clients can access the volume.
	SecurityStyle *string `json:"security_style,omitempty"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePatch.SecurityStyle property.
// The security style for the storage volume:
// - `unix`: NFS clients can access the storage volume.
// - `windows`: SMB/CIFS clients can access the storage volume.
// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
// - `none`: No clients can access the volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePatch_SecurityStyle_Mixed   = "mixed"
	StorageOntapInstanceStorageVirtualMachineVolumePatch_SecurityStyle_None    = "none"
	StorageOntapInstanceStorageVirtualMachineVolumePatch_SecurityStyle_Unix    = "unix"
	StorageOntapInstanceStorageVirtualMachineVolumePatch_SecurityStyle_Windows = "windows"
)

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePatch unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumePatch from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumePatch)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cifs_share", &obj.CifsShare, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePatch)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "export_policy", &obj.ExportPolicy, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPatch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_style", &obj.SecurityStyle)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the StorageOntapInstanceStorageVirtualMachineVolumePatch
func (storageOntapInstanceStorageVirtualMachineVolumePatch *StorageOntapInstanceStorageVirtualMachineVolumePatch) AsPatch() (_patch map[string]interface{}, err error) {
	var jsonData []byte
	jsonData, err = json.Marshal(storageOntapInstanceStorageVirtualMachineVolumePatch)
	if err == nil {
		err = json.Unmarshal(jsonData, &_patch)
	}
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumePrototype : StorageOntapInstanceStorageVirtualMachineVolumePrototype struct
// Models which "extend" this model:
// - StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity
type StorageOntapInstanceStorageVirtualMachineVolumePrototype struct {
	// The name for this storage volume. The name must be unique across all storage volumes in the storage virtual machine.
	//
	// If unspecified, the name will be an underscore-separated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The capacity of the storage volume (in gigabytes).
	Capacity *int64 `json:"capacity,omitempty"`

	// The named access point that enables CIFS clients to view, browse, and manipulate
	// files on this storage volume.
	//
	// This must be specified if `security_style` is `mixed` or `windows`.
	CifsShare *StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype `json:"cifs_share,omitempty"`

	// Indicates whether storage efficiency is enabled for the storage volume.
	//
	// If `true`, data-deduplication, compression and other efficiencies for space-management are enabled for this volume.
	// Deprecated: this field is deprecated and may be removed in a future release.
	EnableStorageEfficiency *bool `json:"enable_storage_efficiency,omitempty"`

	// The NFS export policy for the storage volume.
	//
	// This must be specified if `security_style` is `mixed` or `unix`.
	ExportPolicy *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype `json:"export_policy,omitempty"`

	// The security style for the storage volume:
	// - `unix`: NFS clients can access the storage volume.
	// - `windows`: SMB/CIFS clients can access the storage volume.
	// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
	// - `none`: No clients can access the volume.
	SecurityStyle *string `json:"security_style,omitempty"`

	// The storage efficiency mode to use for this storage volume:
	// - `disabled`: storage efficiency methods will not be used
	// - `enabled`: data-deduplication, compression and other methods will be used.
	StorageEfficiency *string `json:"storage_efficiency,omitempty"`

	// The type of the storage volume to create.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototype.SecurityStyle property.
// The security style for the storage volume:
// - `unix`: NFS clients can access the storage volume.
// - `windows`: SMB/CIFS clients can access the storage volume.
// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
// - `none`: No clients can access the volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_SecurityStyle_Mixed   = "mixed"
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_SecurityStyle_None    = "none"
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_SecurityStyle_Unix    = "unix"
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_SecurityStyle_Windows = "windows"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototype.StorageEfficiency property.
// The storage efficiency mode to use for this storage volume:
// - `disabled`: storage efficiency methods will not be used
// - `enabled`: data-deduplication, compression and other methods will be used.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_StorageEfficiency_Disabled = "disabled"
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_StorageEfficiency_Enabled  = "enabled"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototype.Type property.
// The type of the storage volume to create.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_Type_DataProtection = "data_protection"
	StorageOntapInstanceStorageVirtualMachineVolumePrototype_Type_ReadWrite      = "read_write"
)

func (*StorageOntapInstanceStorageVirtualMachineVolumePrototype) isaStorageOntapInstanceStorageVirtualMachineVolumePrototype() bool {
	return true
}

type StorageOntapInstanceStorageVirtualMachineVolumePrototypeIntf interface {
	isaStorageOntapInstanceStorageVirtualMachineVolumePrototype() bool
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePrototype unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumePrototype from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumePrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cifs_share", &obj.CifsShare, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_storage_efficiency", &obj.EnableStorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "export_policy", &obj.ExportPolicy, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_style", &obj.SecurityStyle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage_efficiency", &obj.StorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - SubnetIdentityByID
// - SubnetIdentityByCRN
// - SubnetIdentityByHref
type SubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	Crn *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*SubnetIdentity) isaSubnetIdentity() bool {
	return true
}

type SubnetIdentityIntf interface {
	isaSubnetIdentity() bool
}

// UnmarshalSubnetIdentity unmarshals an instance of SubnetIdentity from the specified map of raw messages.
func UnmarshalSubnetIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetReference : SubnetReference struct
type SubnetReference struct {
	// The CRN for this subnet.
	Crn *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *SubnetReferenceDeleted `json:"deleted,omitempty"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The name for this subnet. The name is unique across all subnets in the VPC.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SubnetReference.ResourceType property.
// The resource type.
const (
	SubnetReference_ResourceType_Subnet = "subnet"
)

// UnmarshalSubnetReference unmarshals an instance of SubnetReference from the specified map of raw messages.
func UnmarshalSubnetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalSubnetReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type SubnetReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalSubnetReferenceDeleted unmarshals an instance of SubnetReferenceDeleted from the specified map of raw messages.
func UnmarshalSubnetReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateStorageOntapInstanceOptions : The UpdateStorageOntapInstance options.
type UpdateStorageOntapInstanceOptions struct {
	// The storage ontap instance identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The storage ontap instance patch.
	StorageOntapInstancePatch map[string]interface{} `json:"StorageOntapInstance_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateStorageOntapInstanceOptions : Instantiate UpdateStorageOntapInstanceOptions
func (*OntapV1) NewUpdateStorageOntapInstanceOptions(id string, storageOntapInstancePatch map[string]interface{}) *UpdateStorageOntapInstanceOptions {
	return &UpdateStorageOntapInstanceOptions{
		ID:                        core.StringPtr(id),
		StorageOntapInstancePatch: storageOntapInstancePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateStorageOntapInstanceOptions) SetID(id string) *UpdateStorageOntapInstanceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetStorageOntapInstancePatch : Allow user to set StorageOntapInstancePatch
func (_options *UpdateStorageOntapInstanceOptions) SetStorageOntapInstancePatch(storageOntapInstancePatch map[string]interface{}) *UpdateStorageOntapInstanceOptions {
	_options.StorageOntapInstancePatch = storageOntapInstancePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateStorageOntapInstanceOptions) SetIfMatch(ifMatch string) *UpdateStorageOntapInstanceOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateStorageOntapInstanceOptions) SetHeaders(param map[string]string) *UpdateStorageOntapInstanceOptions {
	options.Headers = param
	return options
}

// UpdateStorageOntapInstanceStorageVirtualMachineOptions : The UpdateStorageOntapInstanceStorageVirtualMachine options.
type UpdateStorageOntapInstanceStorageVirtualMachineOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The storage virtual machine patch.
	StorageOntapInstanceStorageVirtualMachinePatch map[string]interface{} `json:"StorageOntapInstanceStorageVirtualMachine_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateStorageOntapInstanceStorageVirtualMachineOptions : Instantiate UpdateStorageOntapInstanceStorageVirtualMachineOptions
func (*OntapV1) NewUpdateStorageOntapInstanceStorageVirtualMachineOptions(storageOntapInstanceID string, id string, storageOntapInstanceStorageVirtualMachinePatch map[string]interface{}) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	return &UpdateStorageOntapInstanceStorageVirtualMachineOptions{
		StorageOntapInstanceID: core.StringPtr(storageOntapInstanceID),
		ID:                     core.StringPtr(id),
		StorageOntapInstanceStorageVirtualMachinePatch: storageOntapInstanceStorageVirtualMachinePatch,
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineOptions) SetID(id string) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetStorageOntapInstanceStorageVirtualMachinePatch : Allow user to set StorageOntapInstanceStorageVirtualMachinePatch
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineOptions) SetStorageOntapInstanceStorageVirtualMachinePatch(storageOntapInstanceStorageVirtualMachinePatch map[string]interface{}) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	_options.StorageOntapInstanceStorageVirtualMachinePatch = storageOntapInstanceStorageVirtualMachinePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineOptions) SetIfMatch(ifMatch string) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateStorageOntapInstanceStorageVirtualMachineOptions) SetHeaders(param map[string]string) *UpdateStorageOntapInstanceStorageVirtualMachineOptions {
	options.Headers = param
	return options
}

// UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions : The UpdateStorageOntapInstanceStorageVirtualMachineVolume options.
type UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions struct {
	// The storage ontap instance identifier.
	StorageOntapInstanceID *string `json:"storage_ontap_instance_id" validate:"required,ne="`

	// The storage virtual machine identifier.
	StorageVirtualMachineID *string `json:"storage_virtual_machine_id" validate:"required,ne="`

	// The storage volume identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The storage volume patch.
	StorageOntapInstanceStorageVirtualMachineVolumePatch map[string]interface{} `json:"StorageOntapInstanceStorageVirtualMachineVolume_patch" validate:"required"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	// Required if the request body includes an array.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions : Instantiate UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions
func (*OntapV1) NewUpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions(storageOntapInstanceID string, storageVirtualMachineID string, id string, storageOntapInstanceStorageVirtualMachineVolumePatch map[string]interface{}) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	return &UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions{
		StorageOntapInstanceID:  core.StringPtr(storageOntapInstanceID),
		StorageVirtualMachineID: core.StringPtr(storageVirtualMachineID),
		ID:                      core.StringPtr(id),
		StorageOntapInstanceStorageVirtualMachineVolumePatch: storageOntapInstanceStorageVirtualMachineVolumePatch,
	}
}

// SetStorageOntapInstanceID : Allow user to set StorageOntapInstanceID
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceID(storageOntapInstanceID string) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceID = core.StringPtr(storageOntapInstanceID)
	return _options
}

// SetStorageVirtualMachineID : Allow user to set StorageVirtualMachineID
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageVirtualMachineID(storageVirtualMachineID string) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageVirtualMachineID = core.StringPtr(storageVirtualMachineID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetID(id string) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetStorageOntapInstanceStorageVirtualMachineVolumePatch : Allow user to set StorageOntapInstanceStorageVirtualMachineVolumePatch
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetStorageOntapInstanceStorageVirtualMachineVolumePatch(storageOntapInstanceStorageVirtualMachineVolumePatch map[string]interface{}) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.StorageOntapInstanceStorageVirtualMachineVolumePatch = storageOntapInstanceStorageVirtualMachineVolumePatch
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetIfMatch(ifMatch string) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions) SetHeaders(param map[string]string) *UpdateStorageOntapInstanceStorageVirtualMachineVolumeOptions {
	options.Headers = param
	return options
}

// VPCReference : VPCReference struct
type VPCReference struct {
	// The CRN for this VPC.
	Crn *string `json:"crn" validate:"required"`

	// If present, this property indicates the referenced resource has been deleted, and provides
	// some supplementary information.
	Deleted *VPCReferenceDeleted `json:"deleted,omitempty"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The name for this VPC. The name is unique across all VPCs in the region.
	Name *string `json:"name" validate:"required"`

	// The resource type.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPCReference.ResourceType property.
// The resource type.
const (
	VPCReference_ResourceType_Vpc = "vpc"
)

// UnmarshalVPCReference unmarshals an instance of VPCReference from the specified map of raw messages.
func UnmarshalVPCReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deleted", &obj.Deleted, UnmarshalVPCReferenceDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReferenceDeleted : If present, this property indicates the referenced resource has been deleted, and provides some supplementary
// information.
type VPCReferenceDeleted struct {
	// Link to documentation about deleted resources.
	MoreInfo *string `json:"more_info" validate:"required"`
}

// UnmarshalVPCReferenceDeleted unmarshals an instance of VPCReferenceDeleted from the specified map of raw messages.
func UnmarshalVPCReferenceDeleted(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReferenceDeleted)
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixIdentityByHref : AddressPrefixIdentityByHref struct
// This model "extends" AddressPrefixIdentity
type AddressPrefixIdentityByHref struct {
	// The URL for this address prefix.
	Href *string `json:"href" validate:"required"`
}

// NewAddressPrefixIdentityByHref : Instantiate AddressPrefixIdentityByHref (Generic Model Constructor)
func (*OntapV1) NewAddressPrefixIdentityByHref(href string) (_model *AddressPrefixIdentityByHref, err error) {
	_model = &AddressPrefixIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*AddressPrefixIdentityByHref) isaAddressPrefixIdentity() bool {
	return true
}

// UnmarshalAddressPrefixIdentityByHref unmarshals an instance of AddressPrefixIdentityByHref from the specified map of raw messages.
func UnmarshalAddressPrefixIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixIdentityByID : AddressPrefixIdentityByID struct
// This model "extends" AddressPrefixIdentity
type AddressPrefixIdentityByID struct {
	// The unique identifier for this address prefix.
	ID *string `json:"id" validate:"required"`
}

// NewAddressPrefixIdentityByID : Instantiate AddressPrefixIdentityByID (Generic Model Constructor)
func (*OntapV1) NewAddressPrefixIdentityByID(id string) (_model *AddressPrefixIdentityByID, err error) {
	_model = &AddressPrefixIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*AddressPrefixIdentityByID) isaAddressPrefixIdentity() bool {
	return true
}

// UnmarshalAddressPrefixIdentityByID unmarshals an instance of AddressPrefixIdentityByID from the specified map of raw messages.
func UnmarshalAddressPrefixIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CredentialIdentityByCRN : CredentialIdentityByCRN struct
// This model "extends" CredentialIdentity
type CredentialIdentityByCRN struct {
	// The CRN for this credential.
	Crn *string `json:"crn" validate:"required"`
}

// NewCredentialIdentityByCRN : Instantiate CredentialIdentityByCRN (Generic Model Constructor)
func (*OntapV1) NewCredentialIdentityByCRN(crn string) (_model *CredentialIdentityByCRN, err error) {
	_model = &CredentialIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*CredentialIdentityByCRN) isaCredentialIdentity() bool {
	return true
}

// UnmarshalCredentialIdentityByCRN unmarshals an instance of CredentialIdentityByCRN from the specified map of raw messages.
func UnmarshalCredentialIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CredentialIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyIdentityByCRN : EncryptionKeyIdentityByCRN struct
// This model "extends" EncryptionKeyIdentity
type EncryptionKeyIdentityByCRN struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Services Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	Crn *string `json:"crn" validate:"required"`
}

// NewEncryptionKeyIdentityByCRN : Instantiate EncryptionKeyIdentityByCRN (Generic Model Constructor)
func (*OntapV1) NewEncryptionKeyIdentityByCRN(crn string) (_model *EncryptionKeyIdentityByCRN, err error) {
	_model = &EncryptionKeyIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*EncryptionKeyIdentityByCRN) isaEncryptionKeyIdentity() bool {
	return true
}

// UnmarshalEncryptionKeyIdentityByCRN unmarshals an instance of EncryptionKeyIdentityByCRN from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupIdentityByID : ResourceGroupIdentityByID struct
// This model "extends" ResourceGroupIdentity
type ResourceGroupIdentityByID struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentityByID : Instantiate ResourceGroupIdentityByID (Generic Model Constructor)
func (*OntapV1) NewResourceGroupIdentityByID(id string) (_model *ResourceGroupIdentityByID, err error) {
	_model = &ResourceGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*ResourceGroupIdentityByID) isaResourceGroupIdentity() bool {
	return true
}

// UnmarshalResourceGroupIdentityByID unmarshals an instance of ResourceGroupIdentityByID from the specified map of raw messages.
func UnmarshalResourceGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByHref : RoutingTableIdentityByHref struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByHref struct {
	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`
}

// NewRoutingTableIdentityByHref : Instantiate RoutingTableIdentityByHref (Generic Model Constructor)
func (*OntapV1) NewRoutingTableIdentityByHref(href string) (_model *RoutingTableIdentityByHref, err error) {
	_model = &RoutingTableIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutingTableIdentityByHref) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByHref unmarshals an instance of RoutingTableIdentityByHref from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByID : RoutingTableIdentityByID struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByID struct {
	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`
}

// NewRoutingTableIdentityByID : Instantiate RoutingTableIdentityByID (Generic Model Constructor)
func (*OntapV1) NewRoutingTableIdentityByID(id string) (_model *RoutingTableIdentityByID, err error) {
	_model = &RoutingTableIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*RoutingTableIdentityByID) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByID unmarshals an instance of RoutingTableIdentityByID from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByCRN : SecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	Crn *string `json:"crn" validate:"required"`
}

// NewSecurityGroupIdentityByCRN : Instantiate SecurityGroupIdentityByCRN (Generic Model Constructor)
func (*OntapV1) NewSecurityGroupIdentityByCRN(crn string) (_model *SecurityGroupIdentityByCRN, err error) {
	_model = &SecurityGroupIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByCRN) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByHref : SecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupIdentityByHref : Instantiate SecurityGroupIdentityByHref (Generic Model Constructor)
func (*OntapV1) NewSecurityGroupIdentityByHref(href string) (_model *SecurityGroupIdentityByHref, err error) {
	_model = &SecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByHref) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByHref unmarshals an instance of SecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByID : SecurityGroupIdentityByID struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupIdentityByID : Instantiate SecurityGroupIdentityByID (Generic Model Constructor)
func (*OntapV1) NewSecurityGroupIdentityByID(id string) (_model *SecurityGroupIdentityByID, err error) {
	_model = &SecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SecurityGroupIdentityByID) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByID unmarshals an instance of SecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR struct
// This model "extends" StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR struct {
	// The CIDR block containing IP addresses of the NFS clients. The CIDR block `0.0.0.0/0` matches all client addresses.
	//
	// This property may add support for IPv6 CIDR blocks in the future. When processing a value in this property, verify
	// that the CIDR block is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CidrBlock *string `json:"cidr_block" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR(cidrBlock string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR{
		CidrBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR) isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool {
	return true
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CidrBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName struct
// This model "extends" StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName struct {
	// The domain names suffixes of the NFS clients.
	DomainSuffix *string `json:"domain_suffix" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName(domainSuffix string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName{
		DomainSuffix: core.StringPtr(domainSuffix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName) isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool {
	return true
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByDomainName)
	err = core.UnmarshalPrimitive(m, "domain_suffix", &obj.DomainSuffix)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname struct
// This model "extends" StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname struct {
	// The hostname of the NFS client.
	Hostname *string `json:"hostname" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname(hostname string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname{
		Hostname: core.StringPtr(hostname),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname) isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool {
	return true
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByHostname)
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP : StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP struct
// This model "extends" StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient
type StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP struct {
	// The IP address of the NFS client.
	//
	// This property may add support for IPv6 addresses in the future. When processing a value in this property, verify
	// that the address is in an expected format. If it is not, log an error. Optionally halt processing and surface the
	// error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP : Instantiate StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP(address string) (_model *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP) isaStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClient() bool {
	return true
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyRuleClientByIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity : Create a storage volume by capacity.
//
// The specified `security_style` value determines whether the volume will be available via NFS, SMB/CIFS, both, or
// none.  Specify `export_policy` to configure access for NFS clients, and `cifs_share` to configure access for SMB/CIFS
// clients.
// This model "extends" StorageOntapInstanceStorageVirtualMachineVolumePrototype
type StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity struct {
	// The name for this storage volume. The name must be unique across all storage volumes in the storage virtual machine.
	//
	// If unspecified, the name will be an underscore-separated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The capacity of the storage volume (in gigabytes).
	Capacity *int64 `json:"capacity" validate:"required"`

	// The named access point that enables CIFS clients to view, browse, and manipulate
	// files on this storage volume.
	//
	// This must be specified if `security_style` is `mixed` or `windows`.
	CifsShare *StorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype `json:"cifs_share,omitempty"`

	// Indicates whether storage efficiency is enabled for the storage volume.
	//
	// If `true`, data-deduplication, compression and other efficiencies for space-management are enabled for this volume.
	// Deprecated: this field is deprecated and may be removed in a future release.
	EnableStorageEfficiency *bool `json:"enable_storage_efficiency,omitempty"`

	// The NFS export policy for the storage volume.
	//
	// This must be specified if `security_style` is `mixed` or `unix`.
	ExportPolicy *StorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype `json:"export_policy,omitempty"`

	// The security style for the storage volume:
	// - `unix`: NFS clients can access the storage volume.
	// - `windows`: SMB/CIFS clients can access the storage volume.
	// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
	// - `none`: No clients can access the volume.
	SecurityStyle *string `json:"security_style,omitempty"`

	// The storage efficiency mode to use for this storage volume:
	// - `disabled`: storage efficiency methods will not be used
	// - `enabled`: data-deduplication, compression and other methods will be used.
	StorageEfficiency *string `json:"storage_efficiency,omitempty"`

	// The type of the storage volume to create.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity.SecurityStyle property.
// The security style for the storage volume:
// - `unix`: NFS clients can access the storage volume.
// - `windows`: SMB/CIFS clients can access the storage volume.
// - `mixed`: Both SMB/CIFS and NFS clients can access the storage volume.
// - `none`: No clients can access the volume.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_SecurityStyle_Mixed   = "mixed"
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_SecurityStyle_None    = "none"
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_SecurityStyle_Unix    = "unix"
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_SecurityStyle_Windows = "windows"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity.StorageEfficiency property.
// The storage efficiency mode to use for this storage volume:
// - `disabled`: storage efficiency methods will not be used
// - `enabled`: data-deduplication, compression and other methods will be used.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_StorageEfficiency_Disabled = "disabled"
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_StorageEfficiency_Enabled  = "enabled"
)

// Constants associated with the StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity.Type property.
// The type of the storage volume to create.
const (
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_Type_DataProtection = "data_protection"
	StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity_Type_ReadWrite      = "read_write"
)

// NewStorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity : Instantiate StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity (Generic Model Constructor)
func (*OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity(capacity int64) (_model *StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity, err error) {
	_model = &StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity{
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity) isaStorageOntapInstanceStorageVirtualMachineVolumePrototype() bool {
	return true
}

// UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity unmarshals an instance of StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity from the specified map of raw messages.
func UnmarshalStorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageOntapInstanceStorageVirtualMachineVolumePrototypeStorageOntapInstanceStorageVirtualMachineVolumeByCapacity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cifs_share", &obj.CifsShare, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeCIFSSharePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_storage_efficiency", &obj.EnableStorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "export_policy", &obj.ExportPolicy, UnmarshalStorageOntapInstanceStorageVirtualMachineVolumeExportPolicyPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_style", &obj.SecurityStyle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage_efficiency", &obj.StorageEfficiency)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByCRN : SubnetIdentityByCRN struct
// This model "extends" SubnetIdentity
type SubnetIdentityByCRN struct {
	// The CRN for this subnet.
	Crn *string `json:"crn" validate:"required"`
}

// NewSubnetIdentityByCRN : Instantiate SubnetIdentityByCRN (Generic Model Constructor)
func (*OntapV1) NewSubnetIdentityByCRN(crn string) (_model *SubnetIdentityByCRN, err error) {
	_model = &SubnetIdentityByCRN{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByCRN) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByCRN unmarshals an instance of SubnetIdentityByCRN from the specified map of raw messages.
func UnmarshalSubnetIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByHref : SubnetIdentityByHref struct
// This model "extends" SubnetIdentity
type SubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewSubnetIdentityByHref : Instantiate SubnetIdentityByHref (Generic Model Constructor)
func (*OntapV1) NewSubnetIdentityByHref(href string) (_model *SubnetIdentityByHref, err error) {
	_model = &SubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByHref) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByHref unmarshals an instance of SubnetIdentityByHref from the specified map of raw messages.
func UnmarshalSubnetIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByID : SubnetIdentityByID struct
// This model "extends" SubnetIdentity
type SubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewSubnetIdentityByID : Instantiate SubnetIdentityByID (Generic Model Constructor)
func (*OntapV1) NewSubnetIdentityByID(id string) (_model *SubnetIdentityByID, err error) {
	_model = &SubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubnetIdentityByID) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByID unmarshals an instance of SubnetIdentityByID from the specified map of raw messages.
func UnmarshalSubnetIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageOntapInstancesPager can be used to simplify the use of the "ListStorageOntapInstances" method.
type StorageOntapInstancesPager struct {
	hasNext     bool
	options     *ListStorageOntapInstancesOptions
	client      *OntapV1
	pageContext struct {
		next *string
	}
}

// NewStorageOntapInstancesPager returns a new StorageOntapInstancesPager instance.
func (ontap *OntapV1) NewStorageOntapInstancesPager(options *ListStorageOntapInstancesOptions) (pager *StorageOntapInstancesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListStorageOntapInstancesOptions = *options
	pager = &StorageOntapInstancesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  ontap,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *StorageOntapInstancesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *StorageOntapInstancesPager) GetNextWithContext(ctx context.Context) (page []StorageOntapInstance, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListStorageOntapInstancesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.StorageOntapInstances

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *StorageOntapInstancesPager) GetAllWithContext(ctx context.Context) (allItems []StorageOntapInstance, err error) {
	for pager.HasNext() {
		var nextPage []StorageOntapInstance
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstancesPager) GetNext() (page []StorageOntapInstance, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstancesPager) GetAll() (allItems []StorageOntapInstance, err error) {
	return pager.GetAllWithContext(context.Background())
}

// StorageOntapInstanceStorageVirtualMachinesPager can be used to simplify the use of the "ListStorageOntapInstanceStorageVirtualMachines" method.
type StorageOntapInstanceStorageVirtualMachinesPager struct {
	hasNext     bool
	options     *ListStorageOntapInstanceStorageVirtualMachinesOptions
	client      *OntapV1
	pageContext struct {
		next *string
	}
}

// NewStorageOntapInstanceStorageVirtualMachinesPager returns a new StorageOntapInstanceStorageVirtualMachinesPager instance.
func (ontap *OntapV1) NewStorageOntapInstanceStorageVirtualMachinesPager(options *ListStorageOntapInstanceStorageVirtualMachinesOptions) (pager *StorageOntapInstanceStorageVirtualMachinesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListStorageOntapInstanceStorageVirtualMachinesOptions = *options
	pager = &StorageOntapInstanceStorageVirtualMachinesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  ontap,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *StorageOntapInstanceStorageVirtualMachinesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *StorageOntapInstanceStorageVirtualMachinesPager) GetNextWithContext(ctx context.Context) (page []StorageOntapInstanceStorageVirtualMachine, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListStorageOntapInstanceStorageVirtualMachinesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.StorageVirtualMachines

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *StorageOntapInstanceStorageVirtualMachinesPager) GetAllWithContext(ctx context.Context) (allItems []StorageOntapInstanceStorageVirtualMachine, err error) {
	for pager.HasNext() {
		var nextPage []StorageOntapInstanceStorageVirtualMachine
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstanceStorageVirtualMachinesPager) GetNext() (page []StorageOntapInstanceStorageVirtualMachine, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstanceStorageVirtualMachinesPager) GetAll() (allItems []StorageOntapInstanceStorageVirtualMachine, err error) {
	return pager.GetAllWithContext(context.Background())
}

// StorageOntapInstanceStorageVirtualMachineVolumesPager can be used to simplify the use of the "ListStorageOntapInstanceStorageVirtualMachineVolumes" method.
type StorageOntapInstanceStorageVirtualMachineVolumesPager struct {
	hasNext     bool
	options     *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions
	client      *OntapV1
	pageContext struct {
		next *string
	}
}

// NewStorageOntapInstanceStorageVirtualMachineVolumesPager returns a new StorageOntapInstanceStorageVirtualMachineVolumesPager instance.
func (ontap *OntapV1) NewStorageOntapInstanceStorageVirtualMachineVolumesPager(options *ListStorageOntapInstanceStorageVirtualMachineVolumesOptions) (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = fmt.Errorf("the 'options.Start' field should not be set")
		return
	}

	var optionsCopy ListStorageOntapInstanceStorageVirtualMachineVolumesOptions = *options
	pager = &StorageOntapInstanceStorageVirtualMachineVolumesPager{
		hasNext: true,
		options: &optionsCopy,
		client:  ontap,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager) GetNextWithContext(ctx context.Context) (page []StorageOntapInstanceStorageVirtualMachineVolume, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListStorageOntapInstanceStorageVirtualMachineVolumesWithContext(ctx, pager.options)
	if err != nil {
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			err = fmt.Errorf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Volumes

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager) GetAllWithContext(ctx context.Context) (allItems []StorageOntapInstanceStorageVirtualMachineVolume, err error) {
	for pager.HasNext() {
		var nextPage []StorageOntapInstanceStorageVirtualMachineVolume
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager) GetNext() (page []StorageOntapInstanceStorageVirtualMachineVolume, err error) {
	return pager.GetNextWithContext(context.Background())
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *StorageOntapInstanceStorageVirtualMachineVolumesPager) GetAll() (allItems []StorageOntapInstanceStorageVirtualMachineVolume, err error) {
	return pager.GetAllWithContext(context.Background())
}
